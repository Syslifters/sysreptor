import itertools
from uuid import uuid4
from jsonschema import ValidationError
from django.db import models
from django.contrib.postgres.fields import ArrayField
from django.core.serializers.json import DjangoJSONEncoder
from django.utils.translation import gettext_lazy as _

from reportcreator_api.archive.crypto.fields import EncryptedField
from reportcreator_api.pentests.customfields.mixins import EncryptedCustomFieldsMixin
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_CORE, FINDING_FIELDS_PREDEFINED, REPORT_FIELDS_CORE, REPORT_FIELDS_PREDEFINED, finding_field_order_default, finding_fields_default, report_fields_default, report_sections_default
from reportcreator_api.pentests.customfields.types import FieldDefinition, field_definition_to_dict, parse_field_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, set_field_origin
from reportcreator_api.pentests.customfields.validators import FieldDefinitionValidator, SectionDefinitionValidator
from reportcreator_api.pentests.models.common import ImportableMixin, LanguageMixin, LockableMixin, ReviewStatus
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.decorators import cache
from reportcreator_api.utils.error_messages import ErrorMessage
from reportcreator_api.utils.models import BaseModel
from reportcreator_api.pentests import querysets
from reportcreator_api.pentests import cvss as cvss_utils
from reportcreator_api.utils.utils import remove_duplicates


class ProjectTypeScope(models.TextChoices):
    GLOBAL = 'global', _('Global')
    PRIVATE = 'private', _('Private')
    PROJECT = 'project', _('Project')


class ProjectType(LockableMixin, LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)

    # PDF Template
    report_template = EncryptedField(base_field=models.TextField(default=''))
    report_styles = EncryptedField(base_field=models.TextField(default=''))
    report_preview_data = EncryptedField(base_field=models.JSONField(encoder=DjangoJSONEncoder, default=dict))

    # Report
    report_fields = models.JSONField(
        encoder=DjangoJSONEncoder, 
        validators=[FieldDefinitionValidator(core_fields=REPORT_FIELDS_CORE, predefined_fields=REPORT_FIELDS_PREDEFINED)], 
        default=report_fields_default)
    report_sections = models.JSONField(encoder=DjangoJSONEncoder, validators=[SectionDefinitionValidator()], default=report_sections_default)

    # Findings
    finding_fields = models.JSONField(
        encoder=DjangoJSONEncoder, 
        validators=[FieldDefinitionValidator(core_fields=FINDING_FIELDS_CORE, predefined_fields=FINDING_FIELDS_PREDEFINED)], 
        default=finding_fields_default)
    finding_field_order = models.JSONField(encoder=DjangoJSONEncoder, default=finding_field_order_default)

    linked_project = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True, blank=True)
    linked_user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=True, blank=True)

    copy_of = models.ForeignKey(to='ProjectType', on_delete=models.SET_NULL, null=True)

    objects = querysets.ProjectTypeManager()

    class Meta:
        constraints = [
            models.CheckConstraint(
                name='linked_project_or_user',
                check=models.Q(linked_project=None) | models.Q(linked_user=None)
            ),
        ]

    @property
    def finding_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.finding_fields)

    @property
    def report_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.report_fields)
    
    @property
    def scope(self) -> ProjectTypeScope:
        if self.linked_project_id:
            return ProjectTypeScope.PROJECT
        elif self.linked_user_id:
            return ProjectTypeScope.PRIVATE
        elif not self.linked_project_id and not self.linked_user_id:
            return ProjectTypeScope.GLOBAL

    def __str__(self) -> str:
        return self.name

    def clean(self) -> None:
        # Validate report sections contain only defined fields
        if undefined_fields := set(itertools.chain(*map(lambda s: s['fields'], self.report_sections))) - set(self.report_fields.keys()):
            raise ValidationError(_('Unknown fields in section: %(fields)s') % {'fields': list(undefined_fields)})

        # Validate finding field order contains only defined fields
        if undefined_fields := set(self.finding_field_order) - set(self.finding_fields.keys()):
            raise ValidationError(_('Unknown fields in finding order: %(fields)s') % {'fields': list(undefined_fields)})

    def save(self, *args, **kwargs):
        # Ensure static fields are marked correctly
        self.report_fields = field_definition_to_dict(set_field_origin(self.report_fields_obj, predefined_fields=REPORT_FIELDS_CORE | REPORT_FIELDS_PREDEFINED))
        self.finding_fields = field_definition_to_dict(set_field_origin(self.finding_fields_obj, predefined_fields=FINDING_FIELDS_CORE | FINDING_FIELDS_PREDEFINED))

        # Ensure report section definition contains all fields
        section_fields = set()
        for s in self.report_sections:
            s['fields'] = remove_duplicates(s['fields'])
            section_fields |= set(s['fields'])
        report_fields = set(self.report_fields.keys())
        if missing_fields := list(report_fields - section_fields):
            others_section = [s for s in self.report_sections if s['id'] == 'other']
            if others_section:
                others_section = others_section[0]
            else:
                others_section = {
                    'id': 'other',
                    'label': 'Other',
                    'fields': [],
                }
                self.report_sections.append(others_section)
            others_section['fields'].extend(missing_fields)
        # Remove undefined fields from section definition
        for section in self.report_sections:
            for undefined_field in set(section['fields']) - report_fields:
                section['fields'].remove(undefined_field)
        
        # Ensure finding order contains all fields
        finding_fields = set(self.finding_fields.keys())
        self.finding_field_order = remove_duplicates(self.finding_field_order + list(finding_fields))
        # Remove undefined fields from finding order
        for undefined_field in set(self.finding_field_order) - finding_fields:
            self.finding_field_order.remove(undefined_field)

        # Ensure correct structure of report_preview_data
        if set(self.changed_fields).intersection({'report_preview_data', 'report_fields', 'finding_fields'}):
            report_data = self.report_preview_data.get('report')
            if not isinstance(report_data, dict):
                report_data = {}

            self.report_preview_data['report'] = report_data | ensure_defined_structure(
                value=report_data, 
                definition=self.report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
            findings = self.report_preview_data.get('findings')
            if not isinstance(findings, list):
                # Generate findings with demo data
                # Static values for core fields
                findings = [
                    {'title': 'First Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L'}, 
                    {'title': 'Second Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:L'},
                ]
            self.report_preview_data['findings'] = [
                {'id': str(uuid4())} | f | ensure_defined_structure(
                    value=f, 
                    definition=self.finding_fields_obj, 
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
                for f in findings if isinstance(f, dict)
            ]
        
        return super().save(*args, **kwargs)

    def copy(self, **kwargs):
        return ProjectType.objects.copy(self, **kwargs)


class PentestProject(EncryptedCustomFieldsMixin, LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)
    tags = ArrayField(base_field=models.CharField(max_length=255), default=list, blank=True, db_index=True)
    project_type = models.ForeignKey(to='ProjectType', on_delete=models.PROTECT)
    imported_members = ArrayField(base_field=models.JSONField(encoder=DjangoJSONEncoder), default=list, blank=True)

    readonly = models.BooleanField(default=False, db_index=True)
    readonly_since = models.DateTimeField(null=True, db_index=True, editable=False)
    
    copy_of = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True)

    objects = querysets.PentestProjectManager()

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project_type.report_fields_obj

    def __str__(self) -> str:
        return self.name

    def delete(self, using=None, keep_parents=False):
        linked_project_types_to_delete = list(ProjectType.objects \
            .filter(linked_project=self) \
            .annotate(used_by_other=models.Count('pentestproject', filter=~models.Q(pentestproject=models.F('linked_project')))) \
            .filter(used_by_other=0) \
            .values_list('id', flat=True))
        out = super().delete(using=using, keep_parents=keep_parents)
        ProjectType.objects.filter(id__in=linked_project_types_to_delete).delete()
        return out

    def copy(self, **kwargs):
        return PentestProject.objects.copy(self, **kwargs)

    def perform_checks(self) -> list[ErrorMessage]:
        from reportcreator_api.pentests.checks import run_checks
        return list(run_checks(self))


class ProjectMemberRole(BaseModel):
    role = models.CharField(max_length=50, unique=True)
    default = models.BooleanField(default=False)

    @classmethod
    @property
    @cache('ProjectMemberRole.predefined_roles', timeout=10)
    def predefined_roles(cls):
        return ProjectMemberRole.objects.all()

    @classmethod
    @property
    def default_roles(cls) -> list[str]:
        return [r.role for r in cls.predefined_roles if r.default]


class ProjectMemberInfo(BaseModel):
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, related_name='members')
    user = models.ForeignKey(to=PentestUser, on_delete=models.PROTECT)

    roles = ArrayField(base_field=models.CharField(max_length=50, null=False, blank=False), default=list, blank=True)

    class Meta:
        unique_together = [('project', 'user')]


class ReportSection(LockableMixin, BaseModel):
    """
    This model stores section related meta information in the DB.
    The actual section data is stored in project.custom_fields.
    Storing everything in the ReportSection DB model would require complex manipulation of model data when section definitions change 
    (e.g. field moved to another section, field deleted form definition => keep value of section, etc.).
    But storing per-section information (e.g. locking, status tracking and assigning pentesters) is easier on a DB object.
    Therefore some parts are stored in a separate model (everything that is not influenced by section and field definition), 
    but the data still remains in the project.data JSON object.
    """
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='sections')
    section_id = models.CharField(max_length=255, null=False, db_index=True, editable=False)

    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=ReviewStatus.choices, default=ReviewStatus.IN_PROGRESS, db_index=True)

    objects = models.Manager.from_queryset(querysets.ReportSectionQueryset)()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'section_id')]

    @property
    def project_type(self):
        return self.project.project_type

    @property
    def section_definition(self):
        return next(filter(lambda s: s.get('id') == self.section_id, self.project_type.report_sections), {})

    @property
    def section_label(self):
        return self.section_definition.get('label') or ''
    
    @property
    def section_fields(self):
        return self.section_definition.get('fields', [])

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return {f: self.project_type.report_fields_obj.get(f) for f in self.section_fields}
    
    @property
    def data(self):
        report_data = self.project.data
        return {f: report_data.get(f) for f in self.section_fields}

    @property
    def language(self):
        return self.project.language

    def update_data(self, value):
        self.project.update_data(value)


class PentestFinding(EncryptedCustomFieldsMixin, LockableMixin, BaseModel):
    finding_id = models.UUIDField(default=uuid4, db_index=True, editable=False)
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='findings')

    template_id = EncryptedField(base_field=models.UUIDField(null=True, blank=True), null=True, blank=True)
    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=ReviewStatus.choices, default=ReviewStatus.IN_PROGRESS, db_index=True)

    objects = models.Manager.from_queryset(querysets.PentestFindingQueryset)()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'finding_id')]

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project.project_type.finding_fields_obj

    @property
    def language(self):
        return self.project.language

    @property
    def title(self):
        return self.data.get('title')

    @property
    def risk_score(self):
        return cvss_utils.calculate_score(self.data.get('cvss'))

    def __str__(self) -> str:
        return self.title

