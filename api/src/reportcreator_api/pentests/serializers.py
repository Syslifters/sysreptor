from base64 import b64decode
import functools
import io
import json
from django.conf import settings
from rest_framework import serializers, exceptions
from django.db import transaction
from django.db.models import F, Exists, OuterRef
from django.utils import timezone
from reportcreator_api.archive import crypto

from reportcreator_api.archive.crypto import pgp, CryptoError
from reportcreator_api.pentests.customfields.serializers import serializer_from_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, check_definitions_compatible, ensure_defined_structure
from reportcreator_api.pentests.models import FindingTemplate, LockInfo, NotebookPage, PentestFinding, PentestProject, ProjectType, ProjectTypeScope, \
    ReportSection, SourceEnum, \
    UploadedAsset, UploadedImage, ProjectMemberInfo, ProjectMemberRole, UploadedProjectFile, UploadedUserNotebookImage, \
    UserPublicKey, ArchivedProject, ArchivedProjectKeyPart, ArchivedProjectPublicKeyEncryptedKeyPart
from reportcreator_api.users.models import PentestUser
from reportcreator_api.users.serializers import PentestUserSerializer, RelatedUserSerializer
from reportcreator_api.utils.files import compress_image
from reportcreator_api.utils.utils import omit_items


class LockInfoSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    def __init__(self, *args, **kwargs):
        kwargs['read_only'] = True
        super().__init__(*args, **kwargs)
    
    class Meta:
        model = LockInfo
        fields = [
            'created', 'updated', 'last_ping', 'expires', 'user',
        ]
        read_only_fields = ['last_ping']


class ProjectTypeShortSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='projecttype-detail', read_only=True)
    assets = serializers.HyperlinkedIdentityField(view_name='uploadedasset-list', lookup_url_kwarg='projecttype_pk', read_only=True)  

    class Meta:
        model = ProjectType
        fields = [
            'id', 'created', 'updated', 'source', 'scope',
            'name', 'language',
            'details', 'assets',
        ]


class ProjectTypeDetailSerializer(ProjectTypeShortSerializer):
    lock_info = LockInfoSerializer()
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)
    copy_of = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta(ProjectTypeShortSerializer.Meta):
        fields = ProjectTypeShortSerializer.Meta.fields + [
            'copy_of', 'lock_info',
            'report_template', 'report_styles', 'report_preview_data',
            'report_fields', 'report_sections',
            'finding_fields', 'finding_field_order',
        ]


class ProjectTypeCreateSerializer(ProjectTypeDetailSerializer):
    scope = serializers.ChoiceField(choices=[c for c in ProjectTypeScope.choices if c[0] in [ProjectTypeScope.GLOBAL.value, ProjectTypeScope.PRIVATE.value]])
    
    def validate_scope(self, value):
        if value == ProjectTypeScope.PRIVATE and not settings.ENABLE_PRIVATE_DESIGNS:
            raise serializers.ValidationError(f'Scope "{value}" not supported')
        elif value == ProjectTypeScope.GLOBAL and not (self.context['request'].user.is_admin or self.context['request'].user.is_designer):
            raise exceptions.PermissionDenied()
        return value

    def create(self, validated_data):
        scope = validated_data.pop('scope')
        validated_data |= {
            ProjectTypeScope.GLOBAL: {'linked_project': None, 'linked_user': None},
            ProjectTypeScope.PRIVATE: {'linked_project': None, 'linked_user': self.context['request'].user},
        }[scope]
        return super().create(validated_data)


class ProjectTypePreviewSerializer(serializers.ModelSerializer):
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)

    class Meta:
        model = ProjectType
        fields = ['report_template', 'report_styles', 'report_preview_data']


class ProjectTypeRelatedField(serializers.PrimaryKeyRelatedField):
    def get_queryset(self):
        return ProjectType.objects.only_permitted(self.context['request'].user)


class PentestFindingSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='finding_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = ProjectTypeRelatedField(source='project.project_type_id', read_only=True)
    lock_info = LockInfoSerializer(read_only=True)
    template = serializers.PrimaryKeyRelatedField(read_only=True, source='template_id')
    assignee = RelatedUserSerializer(required=False, allow_null=True, default=serializers.CreateOnlyDefault(serializers.CurrentUserDefault()))

    class Meta:
        model = PentestFinding
        fields = [
            'id', 'created', 'updated', 'project', 'project_type', 
            'language', 'lock_info', 'template', 'assignee', 'status',
        ]

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=self.context['project'].project_type.finding_fields_obj, **self.get_extra_kwargs().get('data', {})),
        }

    def create(self, validated_data):
        data = ensure_defined_structure(
            value=validated_data.pop('data', {}), 
            definition=self.context['project'].project_type.finding_fields_obj, 
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
        )
        instance = PentestFinding(
            project=self.context['project'], 
            **validated_data
        )
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class PentestFindingFromTemplateSerializer(PentestFindingSerializer):
    template = serializers.PrimaryKeyRelatedField(queryset=FindingTemplate.objects.all(), required=True, allow_null=False, source='template_id')

    class Meta(PentestFindingSerializer.Meta):
        read_only_fields = ['data']

    @transaction.atomic()
    def create(self, validated_data):
        template = validated_data.pop('template_id')
        finding = super().create(validated_data | {
            'template_id': template.id,
            'data': template.data | validated_data.pop('data', {}),
        })
        FindingTemplate.objects.filter(id=template.id).increment_usage_count()
        return finding


class ProjectMemberInfoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectMemberInfo
        fields = ['roles']
    
    def __init__(self, user_serializer=PentestUserSerializer, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.user_serializer = user_serializer

    def get_related_user_serializer(self):
        s = RelatedUserSerializer(user_serializer=self.user_serializer)
        s.bind('user', self)
        return s

    def to_representation(self, instance):
        return self.get_related_user_serializer().to_representation(instance.user) | \
            super().to_representation(instance)

    def to_internal_value(self, data):
        return super().to_internal_value(data) | {
            'user': self.get_related_user_serializer().to_internal_value(data)
        }


class ImportedProjectMemberInfoSerializer(serializers.ModelSerializer):
    roles = serializers.ListField(child=serializers.CharField(), allow_empty=True)

    class Meta(PentestUserSerializer.Meta):
        fields = omit_items(PentestUserSerializer.Meta.fields, ['username']) + ['roles']
        extra_kwargs = {
            'id': {'read_only': False},
        }


class ImportedProjectMemberInfoListSerializer(serializers.ListSerializer):
    child = ImportedProjectMemberInfoSerializer()

    def update(self, instance, validated_data):
        updated = []
        for d in validated_data:
            i = next(filter(lambda e: str(e.get('id')) == str(d.get('id')), instance), {})
            updated.append(i | d)
        return updated


class PentestProjectSerializer(serializers.ModelSerializer):
    project_type = ProjectTypeRelatedField()
    force_change_project_type = serializers.BooleanField(required=False, default=False, write_only=True)

    members = ProjectMemberInfoSerializer(many=True, required=False)
    imported_members = ImportedProjectMemberInfoListSerializer(required=False)

    copy_of = serializers.PrimaryKeyRelatedField(read_only=True)

    details = serializers.HyperlinkedIdentityField(view_name='pentestproject-detail', read_only=True)
    findings = serializers.HyperlinkedIdentityField(view_name='finding-list', lookup_url_kwarg='project_pk', read_only=True)
    sections = serializers.HyperlinkedIdentityField(view_name='section-list', lookup_url_kwarg='project_pk', read_only=True)
    notes = serializers.HyperlinkedIdentityField(view_name='projectnotebookpage-list', lookup_url_kwarg='project_pk', read_only=True)
    images = serializers.HyperlinkedIdentityField(view_name='uploadedimage-list', lookup_url_kwarg='project_pk', read_only=True)

    class Meta:
        model = PentestProject
        fields = [
            'id', 'created', 'updated',
            'name', 'project_type', 'force_change_project_type', 'language', 'tags', 'readonly', 'source', 'copy_of',
            'members', 'imported_members',
            'details', 'findings', 'sections', 'notes', 'images',
        ]
        read_only_fields = ['readonly']

    def validate_project_type(self, value):
        if self.instance and self.instance.project_type != value and not self.initial_data.get('force_change_project_type'):
            res_finding = check_definitions_compatible(self.instance.project_type.finding_fields_obj, value.finding_fields_obj, path=('finding_fields',))
            res_report = check_definitions_compatible(self.instance.project_type.report_fields_obj, value.report_fields_obj, path=('report_fields',))
            if not res_finding[0] or not res_report[0]:
                raise serializers.ValidationError(['Designs have incompatible field definitions. Converting might result in data loss.'] + res_report[1] + res_finding[1])
        
        return value

    @transaction.atomic
    def create(self, validated_data):
        project_type = validated_data.pop('project_type').copy(linked_user=None, source=SourceEnum.SNAPSHOT, created=timezone.now())
        validated_data.pop('force_change_project_type')

        members = validated_data.pop('members', [])

        project = super().create(validated_data | {
            'project_type': project_type,
            'language': project_type.language,
            'custom_fields': ensure_defined_structure(
                value={
                    'title': validated_data.get('name', 'Report Title'),
                },
                definition=project_type.report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
            ),
        })

        # add current user as member
        if not any(map(lambda m: m.get('user') == self.context['request'].user, members)):
            members.append({'user': self.context['request'].user, 'roles': ProjectMemberRole.default_roles})
        ProjectMemberInfo.objects.bulk_create([ProjectMemberInfo(**m, project=project) for m in members])

        project_type.linked_project = project
        project_type.save(update_fields=['linked_project'])

        return project
    
    def update(self, instance, validated_data):
        members = validated_data.pop('members', None)
        if (imported_members := validated_data.get('imported_members')) is not None:
            validated_data['imported_members'] = self.fields['imported_members'].update(instance.imported_members, imported_members)
        if (project_type := validated_data.get('project_type')) and instance.project_type != project_type and project_type.linked_project != instance:
            validated_data['project_type'] = project_type.copy(
                linked_project=instance, 
                linked_user=None,
                source=SourceEnum.SNAPSHOT, 
                created=timezone.now())

        instance = super().update(instance, validated_data)
        if members is not None:
            PentestProject.objects.set_members(instance=instance, members=[ProjectMemberInfo(**m) for m in members])
        return instance


class ReportSectionSerializer(serializers.ModelSerializer):
    id = serializers.CharField(source='section_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = ProjectTypeRelatedField(source='project.project_type_id', read_only=True)
    label = serializers.CharField(source='section_label', read_only=True)
    fields = serializers.ListField(source='section_fields', child=serializers.CharField(), read_only=True)
    lock_info = LockInfoSerializer()
    assignee = RelatedUserSerializer(required=False, allow_null=True)

    class Meta:
        model = ReportSection
        fields = [
            'id', 'label', 'fields', 'project', 'project_type', 
            'language', 'lock_info', 'assignee', 'status',
        ]
    
    def get_fields(self):
        fields = super().get_fields()
        data_field = serializers.DictField()
        if self.instance and isinstance(self.instance, ReportSection):
            data_field = serializer_from_definition(definition=self.instance.field_definition, **self.get_extra_kwargs().get('data', {}))
        return fields | {
            'data': data_field
        }

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        instance.project.save()
        return super().update(instance, validated_data)


class FindingTemplateSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='findingtemplate-detail', read_only=True)
    lock_info = LockInfoSerializer()

    class Meta:
        model = FindingTemplate
        fields = [
            'id', 'created', 'updated', 'details', 
            'lock_info', 'usage_count', 'source',
            'tags', 'language', 'status', 
        ]
        read_only_fields = ['usage_count']
        extra_kwargs = {
            'tags': {'required': False, 'allow_empty': True}
        }

    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=FindingTemplate.field_definition),
        }

    def create(self, validated_data):
        data = validated_data.pop('data', {})
        instance = FindingTemplate(**validated_data)
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class NotebookPageSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='note_id', read_only=True)
    lock_info = LockInfoSerializer()
    title = serializers.CharField(required=False, allow_blank=True)
    text = serializers.CharField(required=False, allow_blank=True)
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True, read_only=True)

    class Meta:
        model = NotebookPage
        fields = [
            'id', 'created', 'updated', 'lock_info',
            'title', 'text', 'checked', 'icon_emoji', 'status_emoji',
            'order', 'parent',
        ]
        extra_kwargs = {
            'order': {'read_only': True},
        }


class NotebookPageCreateSerializer(NotebookPageSerializer):
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True, required=False)
    
    class Meta(NotebookPageSerializer.Meta):
        extra_kwargs = {
            'order': {'read_only': False, 'required': False, 'allow_null': True},
        }

    def get_notebook_object(self):
        return None
    
    def validate_parent(self, value):
        if value:
            parent = NotebookPage.objects \
                .filter(**self.get_notebook_object()) \
                .filter(note_id=value) \
                .first()
            if not parent:
                raise serializers.ValidationError('Invalid note id')
            return parent
        return value

    @transaction.atomic()
    def create(self, validated_data):
        validated_data['parent'] = validated_data.get('parent', {}).get('note_id')

        if validated_data.get('order'):
            NotebookPage.objects \
                .filter(**self.get_notebook_object()) \
                .filter(parent=validated_data.get('parent')) \
                .filter(order__gte=validated_data.get('order')) \
                .update(order=F('order') + 1)
        else:
            validated_data.pop('order', None)

        return super().create(validated_data | self.get_notebook_object())


class ProjectNotebookPageCreateSerializer(NotebookPageCreateSerializer):
    def get_notebook_object(self):
        return {'project': self.context['project']}


class UserNotebookPageCreateSerializer(NotebookPageCreateSerializer):
    def get_notebook_object(self):
        return {'user': self.context['user']}


class NotebookPageSortSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='note_id')
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True)

    class Meta:
        model = NotebookPage
        fields = ['id', 'parent', 'order']
    
    def validate_id(self, value):
        if not next(filter(lambda n: n.note_id == value, self.parent.instance), None):
            raise serializers.ValidationError('Invalid note id')
        return value
        
    def validate_parent(self, value):
        parent = next(filter(lambda n: n.note_id == value, self.parent.instance), None)
        if value is not None and not parent:
            raise serializers.ValidationError('Invalid note id')
        return parent


class NotebookPageSortListSerializer(serializers.ListSerializer):
    def __init__(self, *args, **kwargs):
        super().__init__(child=NotebookPageSortSerializer(), *args, **kwargs)

    def update(self, instance, validated_data):
        # Update values
        missing_notes = []
        for note in instance:
            if data := next(filter(lambda d: note.note_id == d.get('note_id'), validated_data), None):
                note.parent = data.get('parent', {}).get('note_id')
                note.order = data.get('order')
            else:
                missing_notes.append(note)

        NotebookPage.objects.check_parent_and_order(instance, missing_notes)
        NotebookPage.objects.bulk_update(instance, ['parent_id', 'order'])
        return instance


class UserPublicKeySerializer(serializers.ModelSerializer):
    class Meta:
        model = UserPublicKey
        fields = ['id', 'created', 'updated', 'name', 'enabled', 'public_key', 'public_key_info']
        read_only_fields = ['public_key', 'public_key_info']


class UserPublicKeyRegisterBeginSerializer(UserPublicKeySerializer):
    class Meta(UserPublicKeySerializer.Meta):
        read_only_fields = ['public_key_info']
    
    def create(self, validated_data):
        try:
            public_key_info = pgp.public_key_info(validated_data['public_key'])
        except CryptoError as ex:
            raise serializers.ValidationError(detail=ex.args[0]) from ex

        return UserPublicKey(**validated_data | {
            'public_key_info': public_key_info
        })


class ArchivedProjectKeyPartSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    class Meta:
        model = ArchivedProjectKeyPart
        fields = ['id', 'created', 'updated', 'user', 'is_decrypted', 'decrypted_at']


class ArchivedProjectSerializer(serializers.ModelSerializer):
    key_parts = ArchivedProjectKeyPartSerializer(many=True, read_only=True)

    class Meta:
        model = ArchivedProject
        fields = ['id', 'created', 'updated', 'auto_delete_date', 'name', 'tags', 'threshold', 'key_parts']


class ArchivedProjectPublicKeyEncryptedKeyPartSerializer(serializers.ModelSerializer):
    public_key = UserPublicKeySerializer(read_only=True)

    class Meta:
        model = ArchivedProjectPublicKeyEncryptedKeyPart
        fields = ['id', 'created', 'updated', 'public_key', 'encrypted_data']


class ArchivedProjectKeyPartDecryptSerializer(serializers.Serializer):
    data = serializers.CharField()

    def validate_data(self, value):
        try:
            return b64decode(value)
        except Exception:
            raise serializers.ValidationError('Invalid format. Expected base64 encoded data')

    def validate(self, attrs):
        if self.instance.is_decrypted:
            raise serializers.ValidationError('Already decrypted')
        return super().validate(attrs)

    def update(self, instance, validated_data):
        try:
            with crypto.open(io.BytesIO(instance.encrypted_key_part), mode='rb', key=crypto.EncryptionKey(id=None, key=validated_data['data'])) as c:
                instance.key_part = json.loads(c.read())
                instance.decrypted_at = timezone.now()
        except Exception as ex:
            raise serializers.ValidationError('Decryption of key part failed') from ex
        instance.save()
        output = {
            'status': 'key-part-decrypted'
        }

        # Restore whole project when enough key parts are decrypted
        archive = self.context['archived_project']
        available_key_parts = list(archive.key_parts.exclude(decrypted_at=None))
        if len(available_key_parts) >= archive.threshold:
            project = ArchivedProject.objects.restore_project(archive)
            output |= {
                'status': 'project-restored',
                'project_id': project.id,
            }

        return output


class UploadedFileSerilaizerBase(serializers.ModelSerializer):
    compress_images = True

    resource_type = serializers.SerializerMethodField()

    class Meta:
        fields = ['id', 'created', 'updated', 'resource_type', 'name', 'file']
        extra_kwargs = {
            'file': {'write_only': True}, 
            'name': {'required': False},
        }

    def get_resource_type(self, obj):
        return None

    def get_linked_object(self):
        return None

    def create(self, validated_data):
        if self.compress_images:
            validated_data['file'], validated_data['name'] = compress_image(validated_data['file'], validated_data.get('name'))
        validated_data['linked_object'] = self.get_linked_object()
        validated_data['uploaded_by'] = self.context['request'].user
        return super().create(validated_data)


class UploadedImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedImage

    def get_linked_object(self):
        return self.context['project']
    
    def get_resource_type(self, obj):
        return 'image'


class UploadedUserNotebookImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedUserNotebookImage

    def get_linked_object(self):
        return self.context['user']
    
    def get_resource_type(self, obj):
        return 'user-notebook-image'


class UploadedAssetSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedAsset
    
    def get_linked_object(self):
        return self.context['project_type']
    
    def get_resource_type(self, obj):
        return 'asset'
    

class UploadedProjectFileSerilaizer(UploadedFileSerilaizerBase):
    compress_images = False

    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedProjectFile
    
    def get_linked_object(self):
        return self.context['project']
    
    def get_resource_type(self, obj):
        return 'file'


class PreviewPdfOptionsSerializer(serializers.Serializer):
    project_type = ProjectTypeRelatedField(required=False, allow_null=True)
    report_template = serializers.CharField(required=False, allow_null=True, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_null=True, allow_blank=True)


class PublishPdfOptionsSerializer(serializers.Serializer):
    password = serializers.CharField(required=False, allow_null=True, allow_blank=True)


class ImportSerializer(serializers.Serializer):
    file = serializers.FileField()


class ProjectTypeImportSerializer(ImportSerializer):
    scope = serializers.ChoiceField(choices=[c for c in ProjectTypeScope.choices if c[0] in [ProjectTypeScope.GLOBAL.value, ProjectTypeScope.PRIVATE.value]])
    
    def validate_scope(self, value):
        if value == ProjectTypeScope.PRIVATE and not settings.ENABLE_PRIVATE_DESIGNS:
            raise serializers.ValidationError(f'Scope "{value}" not supported')
        elif value == ProjectTypeScope.GLOBAL and not (self.context['request'].user.is_admin or self.context['request'].user.is_designer):
            raise exceptions.PermissionDenied()
        return value


class PentestProjectReadonlySerializer(serializers.ModelSerializer):
    class Meta:
        model = PentestProject
        fields = ['readonly']


class CopySerializer(serializers.Serializer):
    def update(self, instance, validated_data):
        return instance.copy()


class ProjectTypeCopySerializer(serializers.ModelSerializer):
    scope = serializers.ChoiceField(choices=[c for c in ProjectTypeScope.choices if c[0] in [ProjectTypeScope.GLOBAL.value, ProjectTypeScope.PRIVATE.value]])

    class Meta:
        model = ProjectType
        fields = ['name', 'scope']
        extra_kwargs = {
            'name': {'required': False},
        }
    
    def validate_scope(self, value):
        if value == ProjectTypeScope.PRIVATE and not settings.ENABLE_PRIVATE_DESIGNS:
            raise serializers.ValidationError(f'Scope "{value}" not supported')
        elif value == ProjectTypeScope.GLOBAL and not (self.context['request'].user.is_admin or self.context['request'].user.is_designer):
            raise exceptions.PermissionDenied()
        return value

    def update(self, instance, validated_data):
        return instance.copy(
            name='Copy of ' + instance.name,
            source=SourceEnum.CREATED,
            created=timezone.now(),
            **({
                ProjectTypeScope.GLOBAL: {'linked_user': None, 'linked_project': None},
                ProjectTypeScope.PRIVATE: {'linked_user': self.context['request'].user, 'linked_project': None},
            }[validated_data.pop('scope')])
        )


class PentestProjectCopySerializer(serializers.ModelSerializer):
    project_type = ProjectTypeRelatedField(required=False)

    class Meta:
        model = PentestProject
        fields = ['name', 'project_type']
        extra_kwargs = {'name': {'required': False}}

    def update(self, instance, validated_data):
        return instance.copy(
            name='Copy of ' + instance.name,
            source=SourceEnum.CREATED,
            created=timezone.now(),
            **validated_data,
        )


class PentestProjectCreateArchiveSerializer(serializers.Serializer):
    @functools.cache
    def get_archive_users(self):
        return ArchivedProject.objects.get_archive_users_for_project(self.instance)

    def validate(self, attrs):
        if not self.instance.readonly:
            raise serializers.ValidationError('Cannot archive non-finished project')
        if len(self.get_archive_users()) < settings.ARCHIVING_THRESHOLD:
            raise serializers.ValidationError('Too few users')
        return super().validate(attrs)
    
    @transaction.atomic()
    def update(self, instance, validated_data):
        return ArchivedProject.objects.create_from_project(
            project=instance,
            users=self.get_archive_users(),
            delete_project=True,
        )


class PentestUserCheckArchiveSerializer(PentestUserSerializer):
    is_project_member = serializers.BooleanField()
    has_public_keys = serializers.BooleanField()
    can_restore = serializers.SerializerMethodField()
    warnings = serializers.SerializerMethodField()

    class Meta(PentestUserSerializer.Meta):
        fields = PentestUserSerializer.Meta.fields + ['is_active', 'is_global_archiver', 'is_project_member', 'has_public_keys', 'can_restore', 'warnings']
    
    def get_can_restore(self, obj):
        return obj.is_active and obj.has_public_keys and (obj.is_global_archiver or obj.is_project_member)
    
    def get_warnings(self, obj):
        warnings = []
        if not obj.is_active:
            warnings.append('User is not active')
        if not obj.has_public_keys:
            warnings.append('User has no public keys enabled')
        return warnings

