from django.db.models import signals
from django.dispatch import receiver
from django.utils import timezone
from reportcreator_api.pentests.customfields.types import parse_field_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, has_field_structure_changed

from reportcreator_api.pentests.models import PentestFinding, PentestProject, ProjectType, ReportSection, UploadedAsset, UploadedImage, UploadedProjectFile, UploadedUserNotebookImage
from reportcreator_api.pentests.models.archive import ArchivedProject
from reportcreator_api.utils.models import disable_for_loaddata


@receiver(signals.pre_save, sender=PentestProject)
@disable_for_loaddata
def project_project_type_changed_presave(sender, instance, *args, **kwargs):
    if instance.id is None or instance._state.adding or 'project_type_id' in instance.changed_fields:
        # Convert report data
        instance.update_data(ensure_defined_structure(
            value=instance.data_all, 
            definition=instance.project_type.report_fields_obj, 
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
            include_undefined=True))
        

@receiver(signals.pre_save, sender=PentestProject)
@disable_for_loaddata
def project_set_readonly_since(sender, instance, *args, **kwargs):
    if instance.readonly and not instance.readonly_since:
        instance.readonly_since = timezone.now()
    elif not instance.readonly and instance.readonly_since:
        instance.readonly_since = None


@receiver(signals.post_save, sender=PentestProject)
@disable_for_loaddata
def project_project_type_changed_postsave(sender, instance, created, *args, **kwargs):
    """
    When the project_type of a project changed, update the structure of all fields
    """
    if created or 'project_type_id' in instance.changed_fields:
        # Create/delete report sections
        existing_sections = {s.section_id for s in instance.sections.all()}
        all_sections = {s.get('id') for s in instance.project_type.report_sections}
        if new_sections := all_sections - existing_sections:
            ReportSection.objects.bulk_create([ReportSection(project=instance, section_id=s) for s in new_sections])
        if removed_sections := existing_sections - all_sections:
            ReportSection.objects \
                .filter(project=instance) \
                .filter(section_id__in=removed_sections) \
                .delete()

        # Update finding fields
        updated_findings = list(instance.findings.all().select_related('project__project_type'))
        for finding in updated_findings:
            finding.update_data(ensure_defined_structure(
                value=finding.data_all, 
                definition=instance.project_type.finding_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                include_undefined=True))
        PentestFinding.objects.bulk_update(
            filter(lambda f: f.has_changed, updated_findings), 
            fields=['custom_fields'])


@receiver(signals.post_save, sender=ProjectType)
@disable_for_loaddata
def project_type_field_definition_changed(sender, instance, *args, **kwargs):
    """
    When report_fields or finding_fields structure changed, update the field structure of all projects that are based on this project_type
    """

    if (diff := instance.get_field_diff('report_fields')) and has_field_structure_changed(parse_field_definition(diff[0]), instance.report_fields_obj):
        # Update structure of all reports using that project_type
        updated_projects = list(PentestProject.objects.filter(project_type=instance).select_related('project_type'))
        for project in updated_projects:
            project.update_data(ensure_defined_structure(
                value=project.data_all, 
                definition=instance.report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                include_undefined=True))
        PentestProject.objects.bulk_update(updated_projects, fields=['custom_fields'])

    if (diff := instance.get_field_diff('finding_fields')) and has_field_structure_changed(parse_field_definition(diff[0]), instance.finding_fields_obj):
        # Update structure of all findings of this project_type
        updated_findings = list(PentestFinding.objects.filter(project__project_type=instance).select_related('project__project_type'))
        for finding in updated_findings:
            finding.update_data(ensure_defined_structure(
                value=finding.data_all, 
                definition=instance.finding_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                include_undefined=True))
        PentestFinding.objects.bulk_update(updated_findings, fields=['custom_fields'])

    if (diff := instance.get_field_diff('report_sections')):
        sections_prev = set(map(lambda s: s.get('id'), diff[0]))
        sections_curr = set(map(lambda s: s.get('id'), diff[1]))
        if sections_prev != sections_curr:
            # Create new sections
            if new_sections := sections_curr - sections_prev:
                sections_to_create = []
                for project in PentestProject.objects.filter(project_type=instance).iterator():
                    sections_to_create.extend([ReportSection(project=project, section_id=s) for s in new_sections])
                ReportSection.objects.bulk_create(sections_to_create)

            # Delete removed sections
            if removed_sections := sections_prev - sections_curr:
                ReportSection.objects \
                    .filter(project__project_type=instance) \
                    .filter(section_id__in=removed_sections) \
                    .delete()


@receiver(signals.post_delete, sender=UploadedAsset)
@receiver(signals.post_delete, sender=UploadedImage)
@receiver(signals.post_delete, sender=UploadedUserNotebookImage)
@receiver(signals.post_delete, sender=UploadedProjectFile)
@receiver(signals.post_delete, sender=ArchivedProject)
def uploaded_file_deleted(sender, instance, *args, **kwargs):
    # Delete file when instance is deleted from DB and file on filesystem is no loger referenced
    if instance.file:
        file_referenced = \
            UploadedAsset.objects.filter(file=instance.file) \
            .union(UploadedImage.objects.filter(file=instance.file)) \
            .union(UploadedUserNotebookImage.objects.filter(file=instance.file)) \
            .union(UploadedProjectFile.objects.filter(file=instance.file)) \
            .union(ArchivedProject.objects.filter(file=instance.file)) \
            .exists()
        if not file_referenced:
            instance.file.delete(save=False)
