import dataclasses
import enum
import functools
from frozendict import frozendict
from datetime import date
from inspect import isclass
from types import GenericAlias
from typing import Any, Optional, Union
from django.utils.deconstruct import deconstructible
from reportcreator_api.utils.decorators import freeze_args
from reportcreator_api.utils.utils import is_date_string


@enum.unique
class FieldDataType(enum.Enum):
    STRING = 'string'
    MARKDOWN = 'markdown'
    CVSS = 'cvss'
    OWASP = 'owasp'
    DATE = 'date'
    NUMBER = 'number'
    BOOLEAN = 'boolean'
    ENUM = 'enum'
    COMBOBOX = 'combobox'
    USER = 'user'
    OBJECT = 'object'
    LIST = 'list'


@enum.unique
class FieldOrigin(enum.Enum):
    CORE = 'core'
    PREDEFINED = 'predefined'
    CUSTOM = 'custom'


@enum.unique
class CvssVersion(enum.Enum):
    CVSS40 = 'CVSS:4.0'
    CVSS31 = 'CVSS:3.1'
    ANY = None


@deconstructible
@dataclasses.dataclass
class FieldDefinition:
    type: FieldDataType = None
    label: str = ''
    origin: FieldOrigin = FieldOrigin.CUSTOM


@deconstructible
@dataclasses.dataclass
class BaseStringField(FieldDefinition):
    default: Optional[str] = None
    required: bool = True


@deconstructible
@dataclasses.dataclass
class StringField(BaseStringField):
    spellcheck: bool = False
    pattern: Optional[str] = None
    type: FieldDataType = FieldDataType.STRING


@deconstructible
@dataclasses.dataclass
class MarkdownField(BaseStringField):
    type: FieldDataType = FieldDataType.MARKDOWN


@deconstructible
@dataclasses.dataclass
class CvssField(BaseStringField):
    type: FieldDataType = FieldDataType.CVSS
    cvss_version: CvssVersion = CvssVersion.ANY

@deconstructible
@dataclasses.dataclass
class OwaspField(BaseStringField):
    type: FieldDataType = FieldDataType.OWASP


@deconstructible
@dataclasses.dataclass
class ComboboxField(BaseStringField):
    type: FieldDataType = FieldDataType.COMBOBOX
    suggestions: list[str] = dataclasses.field(default_factory=list)


@deconstructible
@dataclasses.dataclass
class DateField(FieldDefinition):
    default: Optional[str] = None
    required: bool = True
    type: FieldDataType = FieldDataType.DATE

    def __post_init__(self):
        if self.default and not is_date_string(self.default):
            raise ValueError('Default value is not a date', self.default)


@deconstructible
@dataclasses.dataclass
class EnumChoice:
    value: str
    label: str = None

    def __post_init__(self):
        self.label = self.value if not self.label else self.label


@deconstructible
@dataclasses.dataclass
class EnumField(FieldDefinition):
    choices: list[EnumChoice] = dataclasses.field(default_factory=list)
    default: Optional[str] = None
    required: bool = True
    type: FieldDataType = FieldDataType.ENUM

    def __post_init__(self):
        if self.default and self.default not in {c.value for c in self.choices}:
            raise ValueError(
                'Default value is not a valid enum choice', self.default)


@deconstructible
@dataclasses.dataclass
class NumberField(FieldDefinition):
    default: Optional[Union[float, int]] = None
    required: bool = True
    type: FieldDataType = FieldDataType.NUMBER


@deconstructible
@dataclasses.dataclass
class BooleanField(FieldDefinition):
    default: Optional[bool] = None
    type: FieldDataType = FieldDataType.BOOLEAN


@deconstructible
@dataclasses.dataclass
class UserField(FieldDefinition):
    required: bool = True
    type: FieldDataType = FieldDataType.USER


@deconstructible
@dataclasses.dataclass
class ObjectField(FieldDefinition):
    properties: dict[str, FieldDefinition] = dataclasses.field(
        default_factory=dict)
    type: FieldDataType = FieldDataType.OBJECT


@deconstructible
@dataclasses.dataclass
class ListField(FieldDefinition):
    items: FieldDefinition = None
    required: bool = True
    type: FieldDataType = FieldDataType.LIST


_FIELD_DATA_TYPE_CLASSES_MAPPING = {
    FieldDataType.STRING: StringField,
    FieldDataType.MARKDOWN: MarkdownField,
    FieldDataType.CVSS: CvssField,
    FieldDataType.OWASP: OwaspField,
    FieldDataType.DATE: DateField,
    FieldDataType.NUMBER: NumberField,
    FieldDataType.BOOLEAN: BooleanField,
    FieldDataType.ENUM: EnumField,
    FieldDataType.COMBOBOX: ComboboxField,
    FieldDataType.USER: UserField,
    FieldDataType.OBJECT: ObjectField,
    FieldDataType.LIST: ListField,
}


def _field_from_dict(t: type, v: Union[dict, str, Any]) -> FieldDefinition:
    if isinstance(t, GenericAlias):
        if t.__origin__ is list and isinstance(v, (list, tuple)):
            return [_field_from_dict(t.__args__[0], e) for e in v]
        elif t.__origin__ is dict and isinstance(v, (dict, frozendict)):
            return {_field_from_dict(t.__args__[0], k): _field_from_dict(t.__args__[1], e) for k, e in v.items()}
    elif isinstance(v, t):
        return v
    elif isclass(t) and issubclass(t, enum.Enum):
        return t(v)
    elif isinstance(t, date) and isinstance(v, str):
        return date.fromisoformat(v)
    elif dataclasses.is_dataclass(t) and isinstance(v, (dict, frozendict)):
        field_types = {f.name: f.type for f in dataclasses.fields(t)}
        dataclass_args = {f: _field_from_dict(
            field_types[f], v[f]) for f in field_types if f in v}
        try:
            return t(**dataclass_args)
        except TypeError:
            pass

    raise ValueError('Could not decode field definition', v)


def _parse_field_definition_entry(definition: dict) -> FieldDefinition:
    if 'type' not in definition:
        raise ValueError('Field type missing')

    type = FieldDataType(definition['type'])
    type_class = _FIELD_DATA_TYPE_CLASSES_MAPPING[type]
    val = _field_from_dict(type_class, definition)
    if type == FieldDataType.OBJECT:
        val.properties = parse_field_definition(
            definition.get('properties', {}))
    elif type == FieldDataType.LIST:
        val.items = _parse_field_definition_entry(definition.get('items', {}))

    return val


@freeze_args
@functools.lru_cache()
def parse_field_definition(definition: dict) -> dict[str, FieldDefinition]:
    out = {}
    for k, d in definition.items():
        out[k] = _parse_field_definition_entry(d)
    return out


def field_definition_to_dict(definition: Union[dict[str, FieldDefinition], Any]):
    if isinstance(definition, (dict, frozendict)):
        return {k: field_definition_to_dict(v) for k, v in definition.items()}
    elif isinstance(definition, (list, tuple)):
        return [field_definition_to_dict(e) for e in definition]
    elif dataclasses.is_dataclass(definition):
        return field_definition_to_dict(dataclasses.asdict(definition))
    elif isinstance(definition, enum.Enum):
        return definition.value
    elif isinstance(definition, date):
        return date.isoformat()
    else:
        return definition
