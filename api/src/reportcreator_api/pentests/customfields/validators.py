import functools
import itertools
import json
from pathlib import Path

import jsonschema
from django.core.exceptions import ValidationError
from django.utils.deconstruct import deconstructible

from reportcreator_api.pentests.customfields.types import (
    CweField,
    FieldDataType,
    FieldDefinition,
    parse_field_definition,
)
from reportcreator_api.utils.utils import is_unique


@functools.cache
def get_field_definition_schema():
    return jsonschema.Draft202012Validator(schema=json.loads((Path(__file__).parent / 'fielddefinition.schema.json').read_text()))


@functools.cache
def get_section_definition_schema():
    return jsonschema.Draft202012Validator(schema=json.loads((Path(__file__).parent / 'sectiondefinition.schema.json').read_text()))


@functools.cache
def get_finding_ordering_schema():
    return jsonschema.Draft202012Validator(schema=json.loads((Path(__file__).parent / 'findingordering.schema.json').read_text()))


@functools.cache
def get_defaultnotes_schema():
    return jsonschema.Draft202012Validator(schema=json.loads((Path(__file__).parent / 'defaultnotes.schema.json').read_text()))


@deconstructible
class FieldDefinitionValidator:
    def __init__(self, core_fields=None, predefined_fields=None) -> None:
        self.core_fields = core_fields or {}
        self.predefined_fields = predefined_fields or {}

    def definition_contains(self, val: FieldDefinition, ref: FieldDefinition):
        """
        Check if data types and structure of field definitions match recursively
        The defintion `ref` has to be included in `val`.
        `val` may extend the nested structure by adding fields, but may not remove any fields.
        """
        if val.type != ref.type:
            return False
        if val.type == FieldDataType.OBJECT:
            if set(ref.properties.keys()).difference(val.properties.keys()):
                return False
            return all([self.definition_contains(val.properties[k], d) for k, d in ref.properties.items()])
        elif val.type == FieldDataType.LIST:
            return self.definition_contains(val.items, ref.items)
        return True

    def __call__(self, value: dict):
        try:
            get_field_definition_schema().validate(value)
        except jsonschema.ValidationError as ex:
            raise ValidationError('Invalid field definition') from ex

        try:
            parsed_value = parse_field_definition(value)
        except Exception as ex:
            raise ValidationError('Invalid field definition') from ex
        # validate core fields:
        #   required
        #   structure cannot be changed
        #   labels and default values can be changed
        for k, d in self.core_fields.items():
            if k not in parsed_value:
                raise ValidationError(f'Core field "{k}" is required')
            if not self.definition_contains(parsed_value[k], d):
                raise ValidationError(
                    f'Cannot change structure of core field "{k}"')

        # validate predefined fields:
        #   not required
        #   base structure cannot be changed, but can be extended
        #   labels and default values can be changed
        for k, d in self.predefined_fields.items():
            if k in parsed_value and not self.definition_contains(parsed_value[k], d):
                raise ValidationError(
                    f'Cannot change structure of predefined field "{k}"')


@deconstructible
class FieldValuesValidator:
    def __init__(self, field_definitions: dict[str, FieldDefinition], require_all_fields=True) -> None:
        self.schema = self.compile_definition_to_schema(
            field_definitions, require_all_fields=require_all_fields)

    def compile_object(self, definition: dict):
        return {
            'type': 'object',
            'additionalProperties': True,
            'properties': dict(map(lambda t: (t[0], self.compile_field(t[1])), definition.items())),
            'required': list(definition.keys()),
        }

    def compile_field(self, definition: FieldDataType):
        field_type = definition.type
        if field_type in [FieldDataType.STRING, FieldDataType.MARKDOWN, FieldDataType.CVSS, FieldDataType.COMBOBOX]:
            return {'type': ['string', 'null']}
        elif field_type == FieldDataType.DATE:
            return {'type': ['string', 'null'], 'format': 'date'}
        elif field_type == FieldDataType.NUMBER:
            return {'type': ['number', 'null']}
        elif field_type == FieldDataType.BOOLEAN:
            return {'type': ['boolean', 'null']}
        elif field_type == FieldDataType.ENUM:
            return {'type': ['string', 'null'], 'enum': [c.value for c in definition.choices] + [None]}
        elif field_type == FieldDataType.CWE:
            return {'type': ['string', 'null'], 'enum': [f"CWE-{c['id']}" for c in CweField.cwe_definitions()] + [None]}
        elif field_type == FieldDataType.USER:
            return {'type': ['string', 'null'], 'format': 'uuid'}
        elif field_type == FieldDataType.OBJECT:
            return self.compile_object(definition.properties)
        elif field_type == FieldDataType.LIST:
            return {'type': 'array', 'items': self.compile_field(definition.items)}
        else:
            raise ValueError(
                f'Encountered invalid type in field definition: "{field_type}"')

    def compile_definition_to_schema(self, field_definitions, require_all_fields=True):
        schema = {
            "$schema": "https://json-schema.org/draft/2019-09/schema",
            **self.compile_object(field_definitions),
        }
        if not require_all_fields:
            schema['required'] = []
        return jsonschema.Draft202012Validator(schema=schema)

    def __call__(self, value):
        try:
            self.schema.validate(value)
        except jsonschema.ValidationError as ex:
            raise ValidationError(
                'Data does not match field definition') from ex


@deconstructible
class SectionDefinitionValidator:
    def __call__(self, value):
        try:
            get_section_definition_schema().validate(value)
        except jsonschema.ValidationError as ex:
            raise ValidationError('Invalid section definition') from ex

        # validate unique section IDs
        if not is_unique([s['id'] for s in value]):
            raise ValidationError(
                'Invalid section definition: Duplicate section IDs')

        # validate that a field is at most in one section
        section_fields = list(itertools.chain(
            *map(lambda s: s['fields'], value)))
        if len(section_fields) != len(set(section_fields)):
            raise ValidationError(
                'Invalid section definition: Field in multiple sections')


@deconstructible
class FindingOrderingValidator:
    def __call__(self, value):
        try:
            get_finding_ordering_schema().validate(value)
        except jsonschema.ValidationError as ex:
            raise ValidationError('Invalid finding ordering') from ex


@deconstructible
class DefaultNotesValidator:
    def __call__(self, value):
        try:
            get_defaultnotes_schema().validate(value)
        except jsonschema.ValidationError as ex:
            raise
            raise ValidationError('Invalid default notes') from ex

        # Validate unique note IDs
        note_ids = set(map(lambda n: n['id'], value))
        if len(value) != len(note_ids):
            raise ValidationError('Invalid default notes: Duplicate note IDs')

        # Validate parent ID exists
        for note in value:
            if note['parent'] is not None and note['parent'] not in note_ids:
                raise ValidationError(f'Invalid default notes: Parent ID "{note["parent"]}" does not exist')

        # Validate parent-child relationships form a valid tree
        from reportcreator_api.pentests.querysets import NotebookPageManagerBase
        NotebookPageManagerBase().check_parent_and_order(instances=value)
