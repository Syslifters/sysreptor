from base64 import b64decode
import contextlib
import functools
import operator
from asgiref.sync import sync_to_async
from io import BytesIO
from uuid import uuid4
from django.forms import model_to_dict
from django.shortcuts import get_object_or_404
from django.db import transaction
from django.db.models import Prefetch, Q, Exists, OuterRef, ProtectedError
from rest_framework import viewsets, mixins, status, exceptions
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.pagination import CursorPagination
from rest_framework.serializers import Serializer, ValidationError
from rest_framework.filters import OrderingFilter, SearchFilter
from rest_framework.settings import api_settings
from django_filters.rest_framework import DjangoFilterBackend, FilterSet, MultipleChoiceFilter, UUIDFilter
from reportcreator_api.pentests.models.project import ProjectMemberRole

from reportcreator_api.users.models import PentestUser
from reportcreator_api.users.views import APIBadRequestError
from reportcreator_api.utils import license
from reportcreator_api.utils.api import FileResponseAsync, GenericAPIViewAsync, StreamingHttpResponseAsync
from reportcreator_api.archive.import_export import export_project_types, export_projects, export_templates, import_project_types, import_projects, import_templates
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_PREDEFINED
from reportcreator_api.pentests.customfields.types import field_definition_to_dict
from reportcreator_api.pentests.models import FindingTemplate, LockStatus, NotebookPage, PentestFinding, PentestProject, ProjectType, ProjectTypeScope, \
    ReportSection, SourceEnum, UploadedAsset, UploadedImage, ProjectMemberInfo, UploadedProjectFile, UploadedUserNotebookImage, \
    UserPublicKey, ArchivedProject, ArchivedProjectKeyPart
from reportcreator_api.pentests.permissions import ArchivedProjectKeyPartPermissions, IsTemplateEditorOrReadOnly, ProjectPermissions, \
    ProjectSubresourcePermissions, ProjectTypePermissions, ProjectTypeSubresourcePermissions, UserPublicKeyPermissions
from reportcreator_api.tasks.rendering.entry import render_pdf, render_pdf_preview
from reportcreator_api.pentests.serializers import ArchivedProjectKeyPartDecryptSerializer, ArchivedProjectKeyPartSerializer, \
    ArchivedProjectPublicKeyEncryptedKeyPartSerializer, ArchivedProjectSerializer, CopySerializer, FindingTemplateSerializer, ImportSerializer, \
    NotebookPageSerializer, PentestFindingFromTemplateSerializer, PentestFindingSerializer, PentestProjectCreateArchiveSerializer, \
    PentestProjectReadonlySerializer, PentestProjectSerializer, PentestUserCheckArchiveSerializer, PreviewPdfOptionsSerializer, \
    ProjectNotebookPageCreateSerializer, NotebookPageSortListSerializer, ProjectTypeCreateSerializer, ProjectTypeDetailSerializer, ProjectTypeImportSerializer, \
    ProjectTypePreviewSerializer, ProjectTypeShortSerializer, ProjectTypeCopySerializer, PublishPdfOptionsSerializer, ReportSectionSerializer, \
    UploadedAssetSerializer, UploadedImageSerializer, PentestProjectCopySerializer, UploadedProjectFileSerilaizer, \
    UploadedUserNotebookImageSerializer, UserNotebookPageCreateSerializer, UserPublicKeyRegisterBeginSerializer, UserPublicKeySerializer


class ViewSetMixinHelper:
    def get_serializer_for_action(self, action, **kwargs):
        action_bak = self.action
        try:
            self.action = action
            return self.get_serializer(**kwargs)
        finally:
            self.action = action_bak


class LockableViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action in ['lock', 'unlock']:
            return Serializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def lock(self, request, *args, **kwargs):
        instance = self.get_object()
        
        lock_status = instance.lock(request.user, refresh_lock=request.data.get('refresh_lock', True))
        instance.refresh_from_db()
        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data, status={
            LockStatus.CREATED: status.HTTP_201_CREATED,
            LockStatus.REFRESHED: status.HTTP_200_OK,
            LockStatus.FAILED: status.HTTP_403_FORBIDDEN
        }[lock_status])

    @action(detail=True, methods=['post'])
    def unlock(self, request, *args, **kwargs):
        instance = self.get_object()
        if not instance.unlock(request.user):
            raise exceptions.PermissionDenied('Could not lock object')

        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data)

    @contextlib.contextmanager
    def _ensure_locked(self, instance):
        was_locked = instance.is_locked
        if instance.lock(self.request.user, refresh_lock=False) == LockStatus.FAILED:
            raise exceptions.PermissionDenied('Could not lock object')
        yield instance
        if not was_locked and instance.pk is not None:
            instance.unlock(self.request.user)

    def perform_update(self, serializer):
        with self._ensure_locked(serializer.instance):
            return super().perform_update(serializer)

    def perform_destroy(self, instance):
        with self._ensure_locked(instance):
            return super().perform_destroy(instance)


class ExportImportViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action == 'export':
            return Serializer
        elif self.action == 'import_':
            return ImportSerializer
        else:
            return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def export(self, request, **kwargs):
        instance = self.get_object()
        archive = self.perform_export([instance])
        return StreamingHttpResponseAsync(streaming_content=archive, headers={
            'Content-Type': 'application/octet-stream',
            'Content-Disposition': f'inline',
        })
    
    def perform_export(self, instances):
        pass

    @action(detail=False, url_path='import', url_name='import', methods=['post'])
    def import_(self, request, **kwargs):
        import_serializer = self.get_serializer(data=request.data)
        import_serializer.is_valid(raise_exception=True)

        with import_serializer.validated_data['file'].open('rb') as f:
            imported_instances = self.perform_import(f, data=import_serializer.validated_data)
        result_serializer = self.get_serializer_for_action('get', instance=imported_instances, many=True)
        return Response(result_serializer.data, status=status.HTTP_201_CREATED)
    
    def perform_import(self, archive, data):
        pass


class CopyViewSetMixin:
    def get_serializer_class(self):
        if self.action == 'copy':
            return CopySerializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def copy(self, request, *args, **kwargs):
        instance = self.get_object()
        request_serializer = self.get_serializer(instance=instance, data=request.data)
        request_serializer.is_valid(raise_exception=True)
        instance_cp = request_serializer.save()
        
        response_serializer = self.get_serializer_for_action('get', instance=instance_cp)
        return Response(response_serializer.data, status=status.HTTP_201_CREATED)


class ProjectTypeFilter(FilterSet):
    scope = MultipleChoiceFilter(label='Scopes', choices=ProjectTypeScope.choices, method='filter_scopes')
    linked_project = UUIDFilter(label='Linked project', method='filter_linked_project')

    class Meta:
        model = ProjectType
        fields = ['language']

    def filter_scopes(self, queryset, name, value):
        scope_filters = []
        for v in set(value):
            if v == 'global':
                scope_filters.append(Q(linked_project=None) & Q(linked_user=None))
            elif v == 'private':
                scope_filters.append(Q(linked_user=self.request.user))
            elif v == 'project':
                scope_filters.append(Q(linked_project__isnull=False))

        return queryset.filter(functools.reduce(operator.or_, scope_filters))

    def filter_linked_project(self, queryset, name, value):
        return queryset.filter(Q(linked_project=None) | Q(linked_project_id=value))


class ProjectTypeViewSetBase:
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypePermissions]
    queryset = ProjectType.objects.all()
    serializer_class = ProjectTypeDetailSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend, OrderingFilter]
    search_fields = ['name']
    filterset_class = ProjectTypeFilter
    ordering_fields = ['created', 'name']
    ordering = ['-created']
    
    def get_serializer_class(self):
        if self.action == 'list':
            return ProjectTypeShortSerializer
        elif self.action == 'create':
            return ProjectTypeCreateSerializer
        elif self.action == 'preview':
            return ProjectTypePreviewSerializer
        elif self.action == 'copy':
            return ProjectTypeCopySerializer
        elif self.action == 'import_':
            return ProjectTypeImportSerializer
        return super().get_serializer_class()
    
    def get_queryset(self):
        return super().get_queryset() \
            .select_related('lock_info_data', 'lock_info_data__user', 'linked_project', 'linked_user') \
            .prefetch_related(Prefetch('linked_project__members', queryset=ProjectMemberInfo.objects.select_related('user'))) \
            .only_permitted(self.request.user)


class ProjectTypeViewSet(ProjectTypeViewSetBase, LockableViewSetMixin, CopyViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    @action(detail=False, url_path='predefinedfields/findings')
    def get_predefined_finding_fields(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FINDING_FIELDS_PREDEFINED))

    def perform_export(self, instances):
        return export_project_types(instances)
    
    def perform_import(self, archive, data):
        instances = import_project_types(archive)
        if data.get('scope') == ProjectTypeScope.PRIVATE:
            for i in instances:
                i.linked_user = self.request.user
            ProjectType.objects.bulk_update(instances, fields=['linked_user'])
        return instances


class ProjectTypePreviewView(ProjectTypeViewSetBase, GenericAPIViewAsync):
    _action = 'preview'
    throttle_scope = 'pdf'

    async def post(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(data=request.data)

        d = serializer.validated_data
        pdf_preview = await render_pdf_preview(
            report_template=d.get('report_template', ''),
            report_styles=d.get('report_styles', ''),
            report_preview_data=(d.get('report_preview_data') or {}) | {
                'pentesters': [ProjectMemberInfo(user=self.request.user, roles=await sync_to_async(lambda: ProjectMemberRole.default_roles)())],
            },
            project_type=instance
        )
        return Response(data=pdf_preview)


class PentestProjectViewSetBase:
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectPermissions]
    serializer_class = PentestProjectSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend]
    search_fields = ['name', 'tags', 'language']
    filterset_fields = ['language', 'readonly']

    def get_serializer_class(self):
        if self.action == 'generate':
            return PublishPdfOptionsSerializer
        elif self.action == 'preview':
            return PreviewPdfOptionsSerializer
        elif self.action == 'readonly':
            return PentestProjectReadonlySerializer
        elif self.action == 'copy':
            return PentestProjectCopySerializer
        elif self.action == 'upload_image_or_file':
            return UploadedProjectFileSerilaizer
        elif self.action in ['customize_projecttype', 'export_all', 'archive_check']:
            return Serializer
        elif self.action == 'archive':
            return PentestProjectCreateArchiveSerializer
        return super().get_serializer_class()

    def get_queryset(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type') \
            .prefetch_related(Prefetch('members', queryset=ProjectMemberInfo.objects.select_related('user')))
        if self.action in ['check', 'preview', 'generate']:
            qs = qs.prefetch_related('sections', 'findings')
        return qs


class PentestProjectViewSet(PentestProjectViewSetBase, CopyViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    @action(detail=True, methods=['get'])
    def check(self, request, *args, **kwargs):
        instance = self.get_object()
        messages = instance.perform_checks()
        return Response(data=[m.to_dict() for m in messages])
    
    @action(detail=True, methods=['get', 'patch', 'put'])
    def readonly(self, request, *args, **kwargs):
        if request.method == 'get':
            return self.retrieve(request, *args, **kwargs)
        else:
            return self.partial_update(request, *args, **kwargs)
    
    @action(detail=True, url_path='customize-projecttype', methods=['post'])
    def customize_projecttype(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.project_type = instance.project_type.copy(
            name='Customization of ' + instance.project_type.name,
            source=SourceEnum.CUSTOMIZED,
            linked_project=instance,
            linked_user=None)
        instance.save()
        return Response(data={'project_type': instance.project_type.id})
    
    @action(detail=True, url_path='upload', methods=['post'])
    def upload_image_or_file(self, request, *args, **kwargs):
        # First try saving an image, then saving as a regular file
        serializer_context = self.get_serializer_context() | {'project': self.get_object()}
        serializer = UploadedImageSerializer(data=request.data, context=serializer_context)
        if not serializer.is_valid(raise_exception=False):
            serializer = UploadedProjectFileSerilaizer(data=request.data, context=serializer_context)
            serializer.is_valid(raise_exception=True)
        
        serializer.save()
        return Response(data=serializer.data, status=status.HTTP_201_CREATED)
 
    @action(detail=True, methods=['post'], url_path='export/all')
    def export_all(self, *args, **kwargs):
        return self.export(*args, **kwargs)
    
    def perform_export(self, instances):
        return export_projects(instances, export_all=self.action == 'export_all')
    
    def perform_import(self, archive, data):
        projects = import_projects(archive)
        PentestProject.objects.add_member(user=self.request.user, projects=projects)
        return projects
    
    @action(detail=True, methods=['post'])
    def archive(self, request, *args, **kwargs):
        project = self.get_object()
        serializer = self.get_serializer(data=request.data, instance=project)
        serializer.is_valid(raise_exception=True)
        archive = serializer.save()

        archive_serializer = ArchivedProjectSerializer(instance=archive, context=self.get_serializer_context())
        return Response(data=archive_serializer.data, status=status.HTTP_201_CREATED)
    
    @action(detail=True, url_path='archive-check', methods=['get'])
    def archive_check(self, request, *args, **kwargs):
        project = self.get_object()
        users = ArchivedProject.objects \
            .get_possible_archive_users_for_project(project) \
            .annotate_has_public_keys() \
            .annotate(is_project_member=Exists(PentestUser.objects.filter(projectmemberinfo__project=project).filter(pk=OuterRef('pk'))))
        return Response(data={
            'users': PentestUserCheckArchiveSerializer(instance=users, many=True).data
        })


class PentestProjectPreviewView(PentestProjectViewSetBase, GenericAPIViewAsync):
    _action = 'preview'
    throttle_scope = 'pdf'

    async def post(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(instance, data=request.data)
        options = serializer.validated_data

        pdf_preview = await render_pdf(project=instance, **options)
        return Response(data=pdf_preview)


class PentestProjectGenerateView(PentestProjectViewSetBase, GenericAPIViewAsync):
    _action = 'generate'
    throttle_scope = 'pdf'

    async def post(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(instance, data=request.data)
        options = serializer.validated_data

        # Generate final report; optionally encrypt PDF if a password was supplied
        pdf = await render_pdf(project=instance, password=options.get('password'))
        if pdf.get('pdf'):
            return FileResponseAsync(BytesIO(b64decode(pdf['pdf'])), content_type='application/pdf')
        else:
            return Response(data=pdf, status=status.HTTP_400_BAD_REQUEST)             


class PentestFindingViewSet(LockableViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    serializer_class = PentestFindingSerializer
    pagination_class = None
    lookup_field = 'finding_id'

    def get_serializer_class(self):
        if self.action == 'fromtemplate':
            return PentestFindingFromTemplateSerializer
        return super().get_serializer_class()

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def get_queryset(self):
        return PentestFinding.objects \
            .only_permitted(self.request.user) \
            .filter(project=self.kwargs['project_pk']) \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')

    @action(detail=False, methods=['post'])
    def fromtemplate(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)


class ReportSectionViewSet(LockableViewSetMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    serializer_class = ReportSectionSerializer
    pagination_class = None
    lookup_field = 'section_id'

    def get_queryset(self):
        qs = ReportSection.objects \
            .only_permitted(self.request.user) \
            .filter(project__id=self.kwargs['project_pk']) \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')
        if self.request.method in ['PUT', 'PATCH']:
            # Lock project with select_for_update because all section fields of a report are stored in the same DB entity (project).
            # Locking does not prevent race conditions on updating because multiple locks can exist for the same DB object.
            # Therefore updates need to be serialized with select_for_update such that no race conditions occur.
            qs = qs.select_for_update(of=['self', 'project'])
        return qs

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }

    def list(self, *args, **kwargs):
        sections = self.get_queryset()
        # Sort sections
        if sections:
            section_order = [s.get('id') for s in sections[0].project_type.report_sections]
            sections = sorted(sections, key=lambda s: section_order.index(str(s.section_id)))

        serializer = self.get_serializer(sections, many=True)
        return Response(serializer.data)

    def update(self, request, *args, **kwargs):
        with transaction.atomic():
            return super().update(request, *args, **kwargs)


class ArchivedProjectViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [license.ProfessionalLicenseRequired]
    serializer_class = ArchivedProjectSerializer
    filter_backends = [SearchFilter]
    search_fields = ['name', 'tags']

    def get_queryset(self):
        return ArchivedProject.objects \
            .only_permitted(self.request.user) \
            .prefetch_related(Prefetch('key_parts', ArchivedProjectKeyPart.objects.select_related('user')))


class ArchivedProjectKeyPartViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ArchivedProjectKeyPartPermissions, license.ProfessionalLicenseRequired]
    serializer_class = ArchivedProjectKeyPartSerializer
    pagination_class = None

    @functools.cache
    def get_archived_project(self):
        qs = ArchivedProject.objects \
            .only_permitted(self.request.user)
        return get_object_or_404(qs, pk=self.kwargs['archivedproject_pk'])
    
    def get_queryset(self):
        return self.get_archived_project().key_parts \
            .select_related('user')
    
    def get_serializer_class(self):
        if self.action == 'public_key_encrypted_data':
            return ArchivedProjectPublicKeyEncryptedKeyPartSerializer
        elif self.action == 'decrypt':
            return ArchivedProjectKeyPartDecryptSerializer
        return super().get_serializer_class()
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'archived_project': self.get_archived_project()
        }
    
    @action(detail=True, url_path='public-key-encrypted-data', methods=['get'])
    def public_key_encrypted_data(self, request, *args, **kwargs):
        qs = self.get_object().public_key_encrypted_parts \
            .select_related('public_key')
        serializer = self.get_serializer(instance=qs, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def decrypt(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance=instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.save()
        return Response(data)


class NotebookPageViewSetBase(LockableViewSetMixin, viewsets.ModelViewSet):
    pagination_class = None
    lookup_field = 'note_id'
    serializer_class = NotebookPageSerializer
    create_serializer_class = None

    def get_queryset(self):
        return NotebookPage.objects \
            .select_related('parent', 'lock_info_data', 'lock_info_data__user') \
            .order_by('parent', 'order')

    def get_serializer_class(self):
        if self.action == 'sort':
            return NotebookPageSortListSerializer
        elif self.action == 'create':
            return self.create_serializer_class
        return super().get_serializer_class()
    
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def sort(self, request, *arg, **kwargs):
        serializer = self.get_serializer(instance=list(self.get_queryset()), data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(data=serializer.data)


class ProjectNotebookPageViewSet(NotebookPageViewSetBase):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    create_serializer_class = ProjectNotebookPageCreateSerializer

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_queryset(self):
        return super().get_queryset() \
            .filter(project=self.get_project())
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project()
        }
    

class UserNotebookPageViewSet(NotebookPageViewSetBase):
    create_serializer_class = UserNotebookPageCreateSerializer

    def get_user(self):
        return self.request.user

    def get_queryset(self):
        return super().get_queryset() \
            .filter(user=self.get_user())
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'user': self.get_user()
        }


class UploadedFileViewSetMixin:
    @action(detail=False, url_path='name/(?P<filename>[^/]+)')
    def retrieve_by_name(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())
        instance = get_object_or_404(queryset.filter_name(kwargs['filename']))
        self.check_object_permissions(request, instance)
        return FileResponseAsync(instance.file.open(), filename=instance.name)


class UploadedImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    serializer_class = UploadedImageSerializer

    def get_queryset(self):
        return UploadedImage.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.kwargs['project_pk'])

    @functools.cache
    def get_project(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user)
        return get_object_or_404(qs, pk=self.kwargs['project_pk'])

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }
    

class UploadedProjectFileViewSet(UploadedImageViewSet):
    serializer_class = UploadedProjectFileSerilaizer

    def get_queryset(self):
        return UploadedProjectFile.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.kwargs['project_pk'])
    

class UploadedUserNotebookImageViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedUserNotebookImageSerializer

    def get_user(self):
        return self.request.user

    def get_queryset(self):
        return UploadedUserNotebookImage.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.get_user())

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'user': self.get_user()
        }


class UploadedAssetViewSet(UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypeSubresourcePermissions]
    serializer_class = UploadedAssetSerializer

    def get_queryset(self):
        return UploadedAsset.objects \
            .only_permitted(self.request.user) \
            .filter(linked_object=self.kwargs['projecttype_pk'])

    @functools.cache
    def get_project_type(self):
        qs = ProjectType.objects \
            .only_permitted(self.request.user) \
            .select_related('linked_project', 'linked_user') \
            .prefetch_related(Prefetch('linked_project__members', queryset=ProjectMemberInfo.objects.select_related('user')))
        return get_object_or_404(qs, pk=self.kwargs['projecttype_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project_type': self.get_project_type(),
        }


class FindingTemplatePagination(CursorPagination):
    def get_ordering(self, request, queryset, view):
        ordering_filters = [
            filter_cls for filter_cls in getattr(view, 'filter_backends', [])
            if hasattr(filter_cls, 'get_queryset_ordering')
        ]
        if ordering_filters:
            return ordering_filters[0]().get_queryset_ordering(request, queryset, view)
        return super().get_ordering()


class FindingTemplateOrderingFilter(OrderingFilter):
    ordering_fields = ['risk', 'usage']

    def get_queryset_ordering(self, request, queryset, view):
        ordering = self.get_ordering(request, queryset, view)[0]
        if ordering == 'risk':
            return ['risk_score', 'created']
        elif ordering == '-risk':
            return ['-risk_score', '-created']
        elif ordering == 'usage':
            return ['usage_count', 'risk_score', 'created']
        elif ordering == '-usage':
            return ['-usage_count', '-risk_score', '-created']
        else:
            return None

    def filter_queryset(self, request, queryset, view):
        ordering = self.get_queryset_ordering(request, queryset, view)
        if ordering:
            return queryset.order_by(*ordering)
        return queryset

    def get_default_ordering(self, view):
        return ['-risk']


class FindingTemplateViewSet(LockableViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    queryset = FindingTemplate.objects.select_related('lock_info_data', 'lock_info_data__user').all()
    serializer_class = FindingTemplateSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend, FindingTemplateOrderingFilter]
    search_fields = ['title', 'tags', 'language']
    filterset_fields = ['language']
    pagination_class = FindingTemplatePagination
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsTemplateEditorOrReadOnly]

    def paginate_queryset(self, queryset):
        return super().paginate_queryset(queryset)

    @action(detail=False)
    def fielddefinition(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FindingTemplate.field_definition))

    def perform_export(self, instances):
        return export_templates(instances)
    
    def perform_import(self, archive, data):
        return import_templates(archive)


class UserPublicKeyViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet):
    serializer_class = UserPublicKeySerializer
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [UserPublicKeyPermissions, license.ProfessionalLicenseRequired]
    pagination_class = None

    @functools.cache
    def get_user(self):
        user_pk = self.kwargs['pentestuser_pk']
        if user_pk == 'self':
            return self.request.user

        qs = PentestUser.objects.all()
        return get_object_or_404(qs, pk=user_pk)
    
    def get_queryset(self):
        return self.get_user().public_keys.all()
    
    def get_serializer_class(self):
        if self.action == 'register_begin':
            return UserPublicKeyRegisterBeginSerializer
        return super().get_serializer_class()
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'user': self.get_user()
        }
    
    @action(detail=False, url_path='register/begin', methods=['post'])
    def register_begin(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        instance = serializer.save()

        # Verify that users can decrypt with the given public key before registering
        test_data = 'key-verification-' + str(uuid4()) + '\n'
        verification_encrypted = instance.encrypt(test_data.encode())
        self.request.session['public_key_register'] = {
            'instance': model_to_dict(instance),
            'verification': test_data,
        }
        return Response(data={
            'status': 'verify-key',
            'public_key_info': instance.public_key_info,
            'verification': verification_encrypted,
        })
    
    @action(detail=False, url_path='register/complete', methods=['post'])
    def register_complete(self, request, *args, **kwargs):
        public_key_register_state = request.session.get('public_key_register')
        if not public_key_register_state:
            raise APIBadRequestError('No public key registration in progress')
        if public_key_register_state['verification'].strip() != request.data.get('verification', '').strip():
            raise ValidationError('Invalid verification code')

        instance = UserPublicKey(**public_key_register_state['instance'])
        instance.user = self.get_user()
        instance.save()
        serializer = self.get_serializer(instance=instance)
        return Response(data=serializer.data, status=status.HTTP_201_CREATED)

    def perform_destroy(self, instance):
        try:
            instance.delete()
        except ProtectedError:
            raise ValidationError(
                detail='Cannot delete this public key because some archives are encrypted with it. ' +
                       'You can disable it to not be used for archiving in the future.')
