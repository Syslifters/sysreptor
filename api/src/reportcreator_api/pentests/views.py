from base64 import b64decode
import contextlib
from datetime import datetime
import functools
import operator
from asgiref.sync import sync_to_async
from io import BytesIO
from uuid import UUID, uuid4
from django.core.exceptions import ObjectDoesNotExist
from django.forms import model_to_dict
from django.http import Http404
from django.shortcuts import get_object_or_404
from django.db import transaction
from django.db.models import Prefetch, Q, ProtectedError, Value, CharField, prefetch_related_objects
from django.db.models.functions import Cast
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_control
from django.template import loader
from django.urls.converters import UUIDConverter, StringConverter
from rest_framework import views, viewsets, mixins, status, exceptions
from rest_framework.pagination import LimitOffsetPagination
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.serializers import ValidationError
from rest_framework.filters import OrderingFilter, SearchFilter
from rest_framework.settings import api_settings
from django_filters.rest_framework import DjangoFilterBackend, FilterSet, ChoiceFilter, MultipleChoiceFilter, UUIDFilter
from drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiTypes

from reportcreator_api.users.permissions import UserNotebookPermissions
from reportcreator_api.users.views import APIBadRequestError, UserSubresourceViewSetMixin
from reportcreator_api.utils import license
from reportcreator_api.utils.api import CursorMultiPagination, FileResponseAsync, StreamingHttpResponseAsync, ViewSetAsync
from reportcreator_api.archive.import_export import export_project_types, export_projects, export_templates, import_project_types, import_projects, import_templates
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_PREDEFINED
from reportcreator_api.pentests.customfields.types import field_definition_to_dict
from reportcreator_api.pentests.models import FindingTemplate, LockStatus, ProjectNotebookPage, UserNotebookPage, PentestProject, ProjectType, ProjectTypeScope, \
    ProjectMemberInfo, UserPublicKey, ArchivedProject, ArchivedProjectKeyPart, ProjectMemberRole, FindingTemplateTranslation, Language
from reportcreator_api.pentests.permissions import ArchivedProjectKeyPartPermissions, IsTemplateEditorOrReadOnly, ProjectPermissions, \
    ProjectSubresourcePermissions, ProjectTypePermissions, ProjectTypeSubresourcePermissions, UserPublicKeyPermissions
from reportcreator_api.tasks.rendering.entry import render_pdf, render_pdf_preview, render_note_to_pdf, render_project_markdown_fields_to_html
from reportcreator_api.pentests.serializers import *
from reportcreator_api.utils.utils import parse_date_string


class ViewSetMixinHelper:
    def get_serializer_for_action(self, action, **kwargs):
        action_bak = self.action
        try:
            self.action = action
            return self.get_serializer(**kwargs)
        finally:
            self.action = action_bak


class LockableViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action in ['lock', 'unlock']:
            return LockableObjectSerializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def lock(self, request, *args, **kwargs):
        instance = self.get_object()
        
        lock_status = instance.lock(request.user, refresh_lock=request.data.get('refresh_lock', True))
        instance.refresh_from_db()
        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data, status={
            LockStatus.CREATED: status.HTTP_201_CREATED,
            LockStatus.REFRESHED: status.HTTP_200_OK,
            LockStatus.FAILED: status.HTTP_403_FORBIDDEN
        }[lock_status])

    @action(detail=True, methods=['post'])
    def unlock(self, request, *args, **kwargs):
        instance = self.get_object()
        if not instance.unlock(request.user):
            raise exceptions.PermissionDenied('Could not lock object')

        serializer = self.get_serializer_for_action('get', instance=instance)
        return Response(serializer.data)

    @contextlib.contextmanager
    def _ensure_locked(self, instance):
        was_locked = instance.is_locked
        if instance.lock(self.request.user, refresh_lock=False) == LockStatus.FAILED:
            raise exceptions.PermissionDenied('Could not lock object')
        yield instance
        if not was_locked and instance.pk is not None:
            instance.unlock(self.request.user)

    def perform_update(self, serializer):
        with self._ensure_locked(serializer.instance):
            return super().perform_update(serializer)

    def perform_destroy(self, instance):
        with self._ensure_locked(instance):
            return super().perform_destroy(instance)


class ExportImportViewSetMixin(ViewSetMixinHelper):
    def get_serializer_class(self):
        if self.action == 'export':
            return ExportSerializer
        elif self.action == 'import_':
            return ImportSerializer
        else:
            return super().get_serializer_class()

    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=True, methods=['post'])
    def export(self, request, **kwargs):
        instance = self.get_object()
        archive = self.perform_export([instance])
        return StreamingHttpResponseAsync(streaming_content=archive, headers={
            'Content-Type': 'application/octet-stream',
            'Content-Disposition': f'inline',
        })
    
    def perform_export(self, instances):
        pass

    @action(detail=False, url_path='import', url_name='import', methods=['post'])
    def import_(self, request, **kwargs):
        import_serializer = self.get_serializer(data=request.data)
        import_serializer.is_valid(raise_exception=True)

        with import_serializer.validated_data['file'].open('rb') as f:
            imported_instances = self.perform_import(f, data=import_serializer.validated_data)
        result_serializer = self.get_serializer_for_action('get', instance=imported_instances, many=True)
        return Response(result_serializer.data, status=status.HTTP_201_CREATED)
    
    def perform_import(self, archive, data, **kwargs):
        pass


class CopyViewSetMixin:
    def get_serializer_class(self):
        if self.action == 'copy':
            return CopySerializer
        return super().get_serializer_class()

    @action(detail=True, methods=['post'])
    def copy(self, request, *args, **kwargs):
        instance = self.get_object()
        request_serializer = self.get_serializer(instance=instance, data=request.data)
        request_serializer.is_valid(raise_exception=True)
        instance_cp = request_serializer.save()
        
        response_serializer = self.get_serializer_for_action('get', instance=instance_cp)
        return Response(response_serializer.data, status=status.HTTP_201_CREATED)


class HistoryTimelineViewSetMixin:
    def get_serializer_class(self):
        if self.action == 'history_timeline':
            return HistoryTimelineSerializer
        return super().get_serializer_class()
    
    @action(detail=True, methods=['get'], url_path='history-timeline', pagination_class=LimitOffsetPagination)
    def history_timeline(self, request, *args, **kwargs):
        if not license.is_professional():
            raise license.LicenseError('Professional license required')
        
        # Django does not support filtering querysets after union().
        # This prevents us from using the default cursor pagination, because this breaks history timelines from multiple tables.
        # Instead we have to use LimitOffsetPagination here.
        queryset = self.get_history_timeline_queryset()
        page = self.paginate_queryset(queryset)
        serializer = self.get_serializer(instance=page, many=True)
        return self.get_paginated_response(serializer.data)
    
    def get_history_timeline_queryset(self):
        timeline_querysets = self.get_history_timeline_queryset_parts()
        queryset = None
        for qs in timeline_querysets:
            if 'model_id' not in qs.query.annotations:
                qs = qs.annotate(model_id=Cast(F('id'), output_field=CharField()))
            qs = qs \
                .annotate(history_model=Value(qs.model.instance_type.__name__)) \
                .select_related('history_user') \
                .only('history_date', 'history_type', 'history_user', 'history_change_reason', 'id')
            if queryset is None:
                queryset = qs
            else:
                queryset = queryset.union(qs)
        
        return queryset \
            .order_by('-history_date', '-history_model', 'id')
        
    def get_history_timeline_queryset_parts(self):
        return []


@extend_schema(parameters=[OpenApiParameter(name='history_date', type=datetime, location=OpenApiParameter.PATH)])
class HistoryViewSetBase(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    lookup_url_kwarg = 'history_date'
    lookup_value_regex = '[^/]+'

    def get_history_date(self):
        try:
            return parse_date_string(self.kwargs[self.lookup_url_kwarg])
        except ValueError:
            raise ValidationError('Invalid history_date')
    
    def get_queryset(self):
        return []

    def get_base_object(self):
        return None
    
    def get_object(self):
        instance = self.get_base_object()
        self.check_object_permissions(self.request, instance)
        return instance
    
    def retrieve_historic(self, get_instance=None, prefetch=None):
        try:
            instance = get_instance() if get_instance else self.get_object().history.as_of(self.get_history_date())
        except ObjectDoesNotExist:
            raise Http404()
        
        if prefetch:
                prefetch_related_objects([instance], *prefetch)
        serializer = self.get_serializer(instance=instance)
        return Response(data=serializer.data)
    
    def retrieve_historic_file(self, model, filename):
        queryset = model.history \
            .as_of(self.get_history_date()) \
            .filter(linked_object_id=self.get_object().id) \
            .filter(name_hash=model.hash_name(filename))
        instance = get_object_or_404(queryset)
        return FileResponseAsync(instance.file.open(), filename=instance.name)
    
    def retrieve(self, request, *args, **kwargs):
        return self.retrieve_historic()


@extend_schema(parameters=[OpenApiParameter(name='project_id', type=UUID, location=OpenApiParameter.PATH)])
@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class ProjectSubresourceMixin(views.APIView):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectSubresourcePermissions]
    pagination_class = None

    @functools.cache
    def get_project(self):
        if not self.request:
            return None
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .select_related('project_type')
        return get_object_or_404(qs, pk=self.kwargs.get('project_pk'))

    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project': self.get_project(),
        }


@extend_schema(parameters=[OpenApiParameter(name='projecttype_id', type=UUID, location=OpenApiParameter.PATH)])
@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class ProjectTypeSubresourceMixin(views.APIView):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypeSubresourcePermissions]

    @functools.cache
    def get_project_type(self):
        qs = ProjectType.objects \
            .only_permitted(self.request.user) \
            .select_related('linked_project', 'linked_user') \
            .prefetch_related(Prefetch('linked_project__members', queryset=ProjectMemberInfo.objects.select_related('user')))
        return get_object_or_404(qs, pk=self.kwargs['projecttype_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'project_type': self.get_project_type(),
        }


@extend_schema(parameters=[OpenApiParameter(name='template_id', type=UUID, location=OpenApiParameter.PATH)])
@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class TemplateSubresourceMixin(views.APIView):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsTemplateEditorOrReadOnly]
    pagination_class = None

    @functools.cache
    def get_template(self):
        if not self.request:
            return None
        qs = FindingTemplate.objects \
            .select_related('lock_info_data', 'lock_info_data__user')
        return get_object_or_404(qs, pk=self.kwargs['template_pk'])
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'template': self.get_template()
        }
    
    def _ensure_locked(self):
        return LockableViewSetMixin._ensure_locked(self, self.get_template())
    
    def perform_create(self, serializer):
        with self._ensure_locked():
            return super().perform_create(serializer)
    
    def perform_update(self, serializer):
        with self._ensure_locked():
            return super().perform_update(serializer)
    
    def perform_destroy(self, instance):
        with self._ensure_locked():
            return super().perform_destroy(instance)


class ProjectTypeFilter(FilterSet):
    scope = MultipleChoiceFilter(label='Scopes', choices=ProjectTypeScope.choices, method='filter_scopes')
    linked_project = UUIDFilter(label='Linked project', method='filter_linked_project')

    class Meta:
        model = ProjectType
        fields = ['language']

    def filter_scopes(self, queryset, name, value):
        scope_filters = []
        for v in set(value):
            if v == 'global':
                scope_filters.append(Q(linked_project=None) & Q(linked_user=None))
            elif v == 'private':
                scope_filters.append(Q(linked_user=self.request.user))
            elif v == 'project':
                scope_filters.append(Q(linked_project__isnull=False))

        return queryset.filter(functools.reduce(operator.or_, scope_filters))

    def filter_linked_project(self, queryset, name, value):
        return queryset.filter(Q(linked_project=None) | Q(linked_project_id=value))


class ProjectTypeOrderingFilter(OrderingFilter):
    ordering_fields = ['created', 'name', 'scope']

    def get_queryset_ordering(self, request, queryset, view):
        ordering_query = self.get_ordering(request, queryset, view)[0]
        if ordering_query == 'scope':
            return ['scope_order', 'name', '-created']
        elif ordering_query == '-scope':
            return ['-scope_order', '-name', 'created']
        return [ordering_query]

    def filter_queryset(self, request, queryset, view):
        ordering = self.get_queryset_ordering(request, queryset, view)
        if ordering:
            if 'scope_order' in ''.join(ordering):
                queryset = queryset.annotate_scope_order()
            return queryset.order_by(*ordering)
        return queryset

    def get_default_ordering(self, view):
        return ['-created']


@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class ProjectTypeViewSet(LockableViewSetMixin, CopyViewSetMixin, ExportImportViewSetMixin, HistoryTimelineViewSetMixin, viewsets.ModelViewSet, ViewSetAsync):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypePermissions]
    queryset = ProjectType.objects.all()
    serializer_class = ProjectTypeDetailSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend, ProjectTypeOrderingFilter]
    search_fields = ['name']
    filterset_class = ProjectTypeFilter
    pagination_class = CursorMultiPagination
    
    def get_serializer_class(self):
        if self.action == 'list':
            return ProjectTypeShortSerializer
        elif self.action == 'create':
            return ProjectTypeCreateSerializer
        elif self.action == 'preview':
            return ProjectTypePreviewSerializer
        elif self.action == 'copy':
            return ProjectTypeCopySerializer
        elif self.action == 'import_':
            return ProjectTypeImportSerializer
        return super().get_serializer_class()
    
    def get_queryset(self):
        qs = super().get_queryset() \
            .select_related('lock_info_data', 'lock_info_data__user', 'linked_project', 'linked_user') \
            .prefetch_related(Prefetch('linked_project__members', queryset=ProjectMemberInfo.objects.select_related('user'))) \
            .only_permitted(self.request.user)
        return qs

    @action(detail=False, url_path='predefinedfields/findings', methods=['get'])
    def get_predefined_finding_fields(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FINDING_FIELDS_PREDEFINED))
    
    @action(detail=True, methods=['post'], throttle_scope='pdf')
    async def preview(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(data=request.data)
        d = serializer.validated_data
        pdf_preview = await render_pdf_preview(
            report_template=d.get('report_template', ''),
            report_styles=d.get('report_styles', ''),
            report_preview_data=(d.get('report_preview_data') or {}) | {
                'pentesters': [ProjectMemberInfo(user=self.request.user, roles=await sync_to_async(lambda: ProjectMemberRole.default_roles)())],
            },
            project_type=instance
        )
        return Response(data=pdf_preview)

    def perform_export(self, instances):
        return export_project_types(instances)
    
    def perform_import(self, archive, data, **kwargs):
        instances = import_project_types(archive, **kwargs)
        if data.get('scope') == ProjectTypeScope.PRIVATE:
            for i in instances:
                i.linked_user = self.request.user
            ProjectType.objects.bulk_update(instances, fields=['linked_user'])
            ProjectType.history.filter(id__in=map(lambda pt: pt.id, instances)).update(linked_user_id=self.request.user.id)
        return instances
    
    def get_history_timeline_queryset_parts(self):
        return [
            self.get_object().history.all(),
        ]


class ProjectTypeHistoryViewSet(ProjectTypeSubresourceMixin, HistoryViewSetBase):
    permission_classes = ProjectTypeSubresourceMixin.permission_classes + [license.ProfessionalLicenseRequired]
    serializer_class = ProjectTypeDetailSerializer

    def get_base_object(self):
        return self.get_project_type()

    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=True, url_path='assets/name/(?P<filename>[^/]+)')
    @method_decorator(cache_control(max_age=60 * 60 * 24, private=True))
    def asset_by_name(self, request, *arg, **kwargs):
        return self.retrieve_historic_file(UploadedAsset, filename=self.kwargs['filename'])
    
   
@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class PentestProjectViewSet(CopyViewSetMixin, ExportImportViewSetMixin, HistoryTimelineViewSetMixin, viewsets.ModelViewSet, ViewSetAsync):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectPermissions]
    serializer_class = PentestProjectDetailSerializer
    filter_backends = [SearchFilter, DjangoFilterBackend]
    search_fields = ['name', 'tags', 'language']
    filterset_fields = ['language', 'readonly']

    def get_serializer_class(self):
        if self.action == 'list':
            return PentestProjectShortSerializer
        if self.action == 'generate':
            return PublishPdfOptionsSerializer
        elif self.action == 'preview':
            return PreviewPdfOptionsSerializer
        elif self.action == 'md2html':
            return Md2HtmlOptionsSerializer
        elif self.action == 'check':
            return PentestProjectCheckSerializer
        elif self.action == 'readonly':
            return PentestProjectReadonlySerializer
        elif self.action == 'copy':
            return PentestProjectCopySerializer
        elif self.action == 'upload_image_or_file':
            return UploadedProjectFileSerilaizer
        elif self.action == 'export_all':
            return ExportSerializer
        elif self.action == 'customize_projecttype':
            return CustomizeProjectTypeSerializer
        elif self.action == 'upload_image_or_file':
            return UploadedProjectFileSerilaizer
        elif self.action == 'archive_check':
            return PentestProjectCheckArchiveSerializer
        elif self.action == 'archive':
            return PentestProjectCreateArchiveSerializer
        return super().get_serializer_class()

    def get_queryset(self):
        qs = PentestProject.objects \
            .only_permitted(self.request.user) \
            .prefetch_related(Prefetch('members', queryset=ProjectMemberInfo.objects.select_related('user')))
        if self.action != 'list':
            qs = qs.select_related('project_type')
        if self.action in ['check', 'preview', 'generate', 'retrieve']:
            qs = qs.prefetch_related(
                Prefetch('sections', ReportSection.objects.select_related('lock_info_data', 'lock_info_data__user', 'assignee')), 
                Prefetch('findings', PentestFinding.objects.select_related('lock_info_data', 'lock_info_data__user', 'assignee'))
            )
        return qs

    @action(detail=True, methods=['get'])
    def check(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)
    
    @action(detail=True, methods=['get', 'patch', 'put'])
    def readonly(self, request, *args, **kwargs):
        if request.method == 'get':
            return self.retrieve(request, *args, **kwargs)
        else:
            return self.partial_update(request, *args, **kwargs)
    
    @action(detail=True, url_path='customize-projecttype', methods=['post'])
    def customize_projecttype(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)
    
    @action(detail=True, url_path='upload', methods=['post'])
    def upload_image_or_file(self, request, *args, **kwargs):
        # First try saving an image, then saving as a regular file
        serializer_context = self.get_serializer_context() | {'project': self.get_object()}
        serializer = UploadedImageSerializer(data=request.data, context=serializer_context)
        if not serializer.is_valid(raise_exception=False):
            serializer = UploadedProjectFileSerilaizer(data=request.data, context=serializer_context)
            serializer.is_valid(raise_exception=True)
        
        serializer.save()
        return Response(data=serializer.data, status=status.HTTP_201_CREATED)
 
    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=True, methods=['post'], url_path='export/all')
    def export_all(self, *args, **kwargs):
        return self.export(*args, **kwargs)
    
    def perform_export(self, instances):
        return export_projects(instances, export_all=self.action == 'export_all')
    
    def perform_import(self, archive, data, **kwargs):
        projects = import_projects(archive, **kwargs)
        PentestProject.objects.add_member(user=self.request.user, projects=projects)
        return projects
    
    @extend_schema(responses={201: ArchivedProjectSerializer})
    @action(detail=True, methods=['post'])
    def archive(self, request, *args, **kwargs):
        project = self.get_object()
        serializer = self.get_serializer(data=request.data, context=self.get_serializer_context() | {'project': project})
        serializer.is_valid(raise_exception=True)
        archive = serializer.save()

        archive_serializer = ArchivedProjectSerializer(instance=archive, context=self.get_serializer_context())
        return Response(data=archive_serializer.data, status=status.HTTP_201_CREATED)
    
    @action(detail=True, url_path='archive-check', methods=['get'])
    def archive_check(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)
    
    @extend_schema(responses=PdfResponseSerializer)
    @action(detail=True, methods=['post'], throttle_scope='pdf')
    async def preview(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(instance, data=request.data)
        options = serializer.validated_data

        pdf_preview = await render_pdf(project=instance, **options)
        return Response(data=pdf_preview)
    
    @extend_schema(responses={(200, 'application/pdf'): OpenApiTypes.BINARY, 400: PdfResponseSerializer})
    @action(detail=True, methods=['post'], throttle_scope='pdf')
    async def generate(self, request, *args, **kwargs):
        instance = await self.aget_object()
        serializer = await self.aget_valid_serializer(instance, data=request.data)
        options = serializer.validated_data

        # Generate final report; optionally encrypt PDF if a password was supplied
        data = await render_pdf(project=instance, password=options.get('password'))
        if data.get('pdf'):
            return FileResponseAsync(BytesIO(b64decode(data['pdf'])), content_type='application/pdf')
        else:
            return Response(data=data, status=status.HTTP_400_BAD_REQUEST)
    
    @extend_schema(responses={200: PentestProjectDetailSerializer, 400: ErrorMessageSerializer(many=True)})
    @action(detail=True, methods=['post'], throttle_scope='pdf')
    async def md2html(self, request, *args, **kwargs):
        instance = await self.aget_object()
        
        data = await render_project_markdown_fields_to_html(project=instance, request=request)
        if data.get('result'):
            return Response(data=data['result'])
        else:
            return Response(data=data['messages'], status=status.HTTP_400_BAD_REQUEST)
    
    def get_history_timeline_queryset_parts(self):
        p = self.get_object()
        return [
            p.history.all(),
            ProjectMemberInfo.history.filter(project_id=p.id),
            PentestFinding.history.filter(project_id=p.id).filter(history_type__in=['-']).annotate(model_id=Cast(F('finding_id'), output_field=CharField())),
            ReportSection.history.filter(project_id=p.id).filter(history_type__in=['-']).annotate(model_id=F('section_id')),
            ProjectNotebookPage.history.filter(project_id=p.id).filter(history_type__in=['-']).annotate(model_id=Cast(F('note_id'), output_field=CharField())),
        ]


class PentestFindingViewSet(ProjectSubresourceMixin, LockableViewSetMixin, HistoryTimelineViewSetMixin, viewsets.ModelViewSet):
    serializer_class = PentestFindingSerializer
    lookup_field = 'finding_id'
    lookup_url_kwarg = 'id'

    def get_serializer_class(self):
        if self.action == 'fromtemplate':
            return PentestFindingFromTemplateSerializer
        elif self.action == 'sort':
            return PentestFindingSortListSerializer
        return super().get_serializer_class()

    def get_queryset(self):
        return self.get_project().findings \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')            

    @action(detail=False, methods=['post'])
    def fromtemplate(self, request, *args, **kwargs):
        return super().create(request, *args, **kwargs)
    
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def sort(self, request, *arg, **kwargs):
        serializer = self.get_serializer(instance=list(self.get_queryset()), data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(data=serializer.data)
    
    def get_history_timeline_queryset_parts(self):
        return [
            PentestFinding.history \
                .filter(project_id=self.get_project().id) \
                .filter(finding_id=self.kwargs['id']) \
                .annotate(model_id=F('finding_id'))
        ]


class ReportSectionViewSet(ProjectSubresourceMixin, LockableViewSetMixin, HistoryTimelineViewSetMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet):
    serializer_class = ReportSectionSerializer
    lookup_field = 'section_id'
    lookup_url_kwarg = 'id'

    def get_queryset(self):
        return self.get_project().sections \
            .select_related('project__project_type', 'lock_info_data', 'lock_info_data__user', 'assignee')
    
    def get_history_timeline_queryset_parts(self):
        return [
            ReportSection.history \
                .filter(project_id=self.get_project().id) \
                .filter(section_id=self.kwargs['id']) \
                .annotate(model_id=F('section_id'))
        ]


class PentestProjectHistoryViewSet(ProjectSubresourceMixin, HistoryViewSetBase):
    permission_classes = ProjectSubresourceMixin.permission_classes + [license.ProfessionalLicenseRequired]
    serializer_class = PentestProjectDetailSerializer

    def get_serializer_class(self):
        if self.action == 'finding':
            return PentestFindingSerializer
        elif self.action == 'section':
            return ReportSectionSerializer
        elif self.action == 'note':
            return ProjectNotebookPageSerializer
        return super().get_serializer_class()

    def get_serializer_context(self):
        historic_project = self.get_project().history.as_of(self.get_history_date())
        prefetch_related_objects([historic_project], Prefetch('project_type', ProjectType.history.as_of(self.get_history_date())))

        return super().get_serializer_context() | {
            'project': historic_project,
        }

    def get_base_object(self):
        return self.get_project()
    
    def retrieve(self, request, *args, **kwargs):
        return self.retrieve_historic(prefetch=[
            Prefetch('project_type', ProjectType.history.as_of(self.get_history_date())),
            # Skip members referencing deleted users
            Prefetch('members', ProjectMemberInfo.history.as_of(self.get_history_date()).filter(user__created__isnull=False).select_related('user')),
            Prefetch('sections', ReportSection.history.as_of(self.get_history_date()).select_related('assignee')),
            Prefetch('findings', PentestFinding.history.as_of(self.get_history_date()).select_related('assignee')),
        ])

    @extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
    @action(detail=True, url_path=f'findings/(?P<id>{UUIDConverter.regex})')
    def finding(self, request, *args, **kwargs):
        project = self.get_object()
        return self.retrieve_historic(
            get_instance=lambda: PentestFinding.history
                .as_of(self.get_history_date())
                .filter(project_id=project.id)
                .filter(finding_id=self.kwargs['id'])
                .select_related('assignee')
                .get(),
            prefetch=[
                Prefetch('project', PentestProject.history.as_of(self.get_history_date())),
                Prefetch('project__project_type', ProjectType.history.as_of(self.get_history_date())),
            ]
        )

    @extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
    @action(detail=True, url_path=f'sections/(?P<id>{StringConverter.regex})')
    def section(self, request, *args, **kwargs):
        return self.retrieve_historic(
            get_instance=lambda: ReportSection.history
                .as_of(self.get_history_date())
                .filter(project_id=self.get_object().id)
                .filter(section_id=self.kwargs['id'])
                .select_related('assignee')
                .get(),
            prefetch=[
                Prefetch('project', PentestProject.history.as_of(self.get_history_date())),
                Prefetch('project__project_type', ProjectType.history.as_of(self.get_history_date())),
            ]
        )

    @extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
    @action(detail=True, url_path=f'notes/(?P<id>{UUIDConverter.regex})')
    def note(self, request, *args, **kwargs):
        return self.retrieve_historic(
            get_instance=lambda: ProjectNotebookPage.history
                .as_of(self.get_history_date())
                .filter(project_id=self.get_object().id)
                .filter(note_id=self.kwargs['id'])
                .get(),
            prefetch=[
                Prefetch('parent', ProjectNotebookPage.history.as_of(self.get_history_date())),
            ]
        )

    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=True, url_path='images/name/(?P<filename>[^/]+)')
    @method_decorator(cache_control(max_age=60 * 60 * 24, private=True))
    def image_by_name(self, request, *args, **kwargs):
        return self.retrieve_historic_file(UploadedImage, filename=self.kwargs['filename'])
    
    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=True, url_path='files/name/(?P<filename>[^/]+)')
    @method_decorator(cache_control(max_age=60 * 60 * 24, private=True))
    def file_by_name(self, request, *args, **kwargs):
        return self.retrieve_historic_file(UploadedProjectFile, filename=self.kwargs['filename'])


@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class ArchivedProjectViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [license.ProfessionalLicenseRequired]
    serializer_class = ArchivedProjectSerializer
    filter_backends = [SearchFilter]
    search_fields = ['name', 'tags']

    def get_queryset(self):
        return ArchivedProject.objects \
            .only_permitted(self.request.user) \
            .prefetch_related(Prefetch('key_parts', ArchivedProjectKeyPart.objects.select_related('user')))


@extend_schema(parameters=[OpenApiParameter(name='archivedproject_id', type=UUID, location=OpenApiParameter.PATH)])
@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class ArchivedProjectKeyPartViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ArchivedProjectKeyPartPermissions, license.ProfessionalLicenseRequired]
    serializer_class = ArchivedProjectKeyPartSerializer
    pagination_class = None

    @functools.cache
    def get_archived_project(self):
        qs = ArchivedProject.objects \
            .only_permitted(self.request.user)
        return get_object_or_404(qs, pk=self.kwargs['archivedproject_pk'])
    
    def get_queryset(self):
        return self.get_archived_project().key_parts \
            .select_related('user')
    
    def get_serializer_class(self):
        if self.action == 'public_key_encrypted_data':
            return ArchivedProjectPublicKeyEncryptedKeyPartSerializer
        elif self.action == 'decrypt':
            return ArchivedProjectKeyPartDecryptSerializer
        return super().get_serializer_class()
    
    def get_serializer_context(self):
        return super().get_serializer_context() | {
            'archived_project': self.get_archived_project()
        }
    
    @action(detail=True, url_path='public-key-encrypted-data', methods=['get'])
    def public_key_encrypted_data(self, request, *args, **kwargs):
        qs = self.get_object().public_key_encrypted_parts \
            .select_related('public_key')
        serializer = self.get_serializer(instance=qs, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def decrypt(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance=instance, data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.save()
        return Response(data)


class NotebookPageViewSetBaseMixin:
    pagination_class = None
    lookup_field = 'note_id'
    lookup_url_kwarg = 'id'
    create_serializer_class = None
    sort_serializer_class = None

    def get_serializer_class(self):
        if self.action == 'sort':
            return self.sort_serializer_class
        elif self.action == 'create':
            return self.create_serializer_class
        elif self.action == 'export_pdf':
            return ExportPdfOptionsSerializer
        return super().get_serializer_class()


class NotebookPageViewSetBase(NotebookPageViewSetBaseMixin, LockableViewSetMixin, viewsets.ModelViewSet, ViewSetAsync):
    @action(detail=False, methods=['post'])
    @transaction.atomic
    def sort(self, request, *arg, **kwargs):
        serializer = self.get_serializer(instance=list(self.get_queryset()), data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(data=serializer.data)
    
    @extend_schema(responses={(200, 'application/pdf'): OpenApiTypes.BINARY, 401: PdfResponseSerializer})
    @action(detail=True, url_path='export-pdf', methods=['post'], throttle_scope='pdf')
    async def export_pdf(self, request, *args, **kwargs):
        instance = await self.aget_object()
        data = await render_note_to_pdf(note=instance, request=request)
        if data.get('pdf'):
            return FileResponseAsync(BytesIO(b64decode(data['pdf'])), content_type='application/pdf')
        else:
            return Response(data=data, status=status.HTTP_400_BAD_REQUEST)


class ProjectNotebookPageViewSet(ProjectSubresourceMixin, HistoryTimelineViewSetMixin, NotebookPageViewSetBase):
    serializer_class = ProjectNotebookPageSerializer
    create_serializer_class = ProjectNotebookPageCreateSerializer
    sort_serializer_class = ProjectNotebookPageSortListSerializer

    def get_queryset(self):
        qs = self.get_project().notes.all() \
            .select_related('parent', 'lock_info_data', 'lock_info_data__user') \
            .order_by('parent', 'order')
        if self.action == 'export_pdf':
            qs = qs.select_related('project')
        return qs

    def get_history_timeline_queryset_parts(self):
        return [
            ProjectNotebookPage.history \
                .filter(project_id=self.get_project().id) \
                .filter(note_id=self.kwargs['id']) \
                .annotate(model_id=F('note_id'))
        ]


class UserNotebookPageViewSet(UserSubresourceViewSetMixin, NotebookPageViewSetBase):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [UserNotebookPermissions]
    serializer_class = UserNotebookPageSerializer
    create_serializer_class = UserNotebookPageCreateSerializer
    sort_serializer_class = UserNotebookPageSortListSerializer

    def get_queryset(self):
        qs = self.get_user().notes.all() \
            .select_related('parent', 'lock_info_data', 'lock_info_data__user') \
            .order_by('parent', 'order')
        if self.action == 'export_pdf':
            qs = qs.select_related('user')
        return qs
    
    def get_serializer_class(self):
        if self.action == 'upload_image_or_file':
            return UploadedUserNotebookFileSerilaizer
        return super().get_serializer_class()

    @action(detail=False, url_path='upload', methods=['post'])
    def upload_image_or_file(self, request, *args, **kwargs):
        # First try saving an image, then saving as a regular file
        serializer_context = self.get_serializer_context() | {'user': self.get_user()}
        serializer = UploadedUserNotebookImageSerializer(data=request.data, context=serializer_context)
        if not serializer.is_valid(raise_exception=False):
            serializer = UploadedUserNotebookFileSerilaizer(data=request.data, context=serializer_context)
            serializer.is_valid(raise_exception=True)
        
        serializer.save()
        return Response(data=serializer.data, status=status.HTTP_201_CREATED)


class UploadedFileViewSetMixin:
    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=False, url_path='name/(?P<filename>[^/]+)')
    @method_decorator(cache_control(max_age=60 * 60 * 24, private=True))
    def retrieve_by_name(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())
        instance = get_object_or_404(queryset.filter_name(kwargs['filename']))
        self.check_object_permissions(request, instance)
        return FileResponseAsync(instance.file.open(), filename=instance.name)


class UploadedImageViewSet(ProjectSubresourceMixin, UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedImageSerializer
    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS

    def get_queryset(self):
        return self.get_project().images.all()


class UploadedTemplateImageViewSet(TemplateSubresourceMixin, UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedTemplateImageSerializer
    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS

    def get_queryset(self):
        return self.get_template().images.all()


class UploadedProjectFileViewSet(UploadedImageViewSet):
    serializer_class = UploadedProjectFileSerilaizer

    def get_queryset(self):
        return self.get_project().files.all()
    

class UploadedUserNotebookImageViewSet(UserSubresourceViewSetMixin, UploadedFileViewSetMixin, viewsets.ModelViewSet):
    serializer_class = UploadedUserNotebookImageSerializer
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [UserNotebookPermissions]
    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS

    def get_queryset(self):
        return self.get_user().images.all()
    

class UploadedUserNotebookFileViewSet(UploadedUserNotebookImageViewSet):
    serializer_class = UploadedUserNotebookFileSerilaizer

    def get_queryset(self):
        return self.get_user().files.all()


class UploadedAssetViewSet(ProjectTypeSubresourceMixin, UploadedFileViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [ProjectTypeSubresourcePermissions]
    serializer_class = UploadedAssetSerializer

    def get_queryset(self):
        return self.get_project_type().assets.all()


class FindingTemplateSearchFilter(SearchFilter):
    def filter_queryset(self, request, queryset, view):
        search_terms = self.get_search_terms(request)
        if not search_terms:
            return queryset
        
        return queryset \
            .search(search_terms)
    
    def to_html(self, request, queryset, view):
        context = {
            'param': self.search_param,
            'term': ' '.join(self.get_search_terms(request))
        }
        template = loader.get_template(self.template)
        return template.render(context)


class FindingTemplateOrderingFilter(OrderingFilter):
    ordering_fields = ['risk', 'usage']

    def get_queryset_ordering(self, request, queryset, view):
        ordering_query = self.get_ordering(request, queryset, view)[0]

        # Combine with preferred_language ordering filter
        ordering = []
        existing_ordering = list(queryset.query.order_by)
        if existing_ordering in [['-has_language', '-search_rank'], ['-has_language'], ['-search_rank']]:
            ordering = existing_ordering

        if ordering_query == 'risk':
            return ordering + ['main_translation__risk_score', 'created']
        elif ordering_query == '-risk':
            return ordering + ['-main_translation__risk_score', '-created']
        elif ordering_query == 'usage':
            return ordering + ['usage_count', 'main_translation__risk_score', 'created']
        elif ordering_query == '-usage':
            return ordering + ['-usage_count', '-main_translation__risk_score', '-created']
        else:
            return None

    def filter_queryset(self, request, queryset, view):
        ordering = self.get_queryset_ordering(request, queryset, view)
        if ordering:
            return queryset.order_by(*ordering)
        return queryset

    def get_default_ordering(self, view):
        return ['-risk']


class FindingTemplateFilter(FilterSet):
    language = ChoiceFilter(field_name='translations__language', choices=Language.choices)
    preferred_language = ChoiceFilter(choices=Language.choices, method='filter_preferred_language', label='Preferred Language')

    def filter_preferred_language(self, queryset, name, value):
        return queryset.order_by_language(value)


@extend_schema(parameters=[OpenApiParameter(name='id', type=UUID, location=OpenApiParameter.PATH)])
class FindingTemplateViewSet(LockableViewSetMixin, ExportImportViewSetMixin, viewsets.ModelViewSet):
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [IsTemplateEditorOrReadOnly]
    serializer_class = FindingTemplateSerializer
    filter_backends = [DjangoFilterBackend, FindingTemplateSearchFilter, FindingTemplateOrderingFilter]
    filterset_class = FindingTemplateFilter
    pagination_class = CursorMultiPagination

    def get_queryset(self):
        return FindingTemplate.objects \
            .select_related('main_translation', 'lock_info_data', 'lock_info_data__user') \
            .prefetch_related(Prefetch('translations', FindingTemplateTranslation.objects.default_order()))
    
    def get_serializer_class(self):
        if self.action == 'create':
            return FindingTemplateSerializer
        elif self.action == 'list':
            return FindingTemplateShortSerializer
        elif self.action == 'fromfinding':
            return FindingTemplateFromPentestFindingSerializer
        return super().get_serializer_class()

    @extend_schema(responses=OpenApiTypes.OBJECT)
    @action(detail=False)
    def fielddefinition(self, request, *args, **kwargs):
        return Response(data=field_definition_to_dict(FindingTemplate.field_definition))
    
    @action(detail=False, methods=['post'])
    def fromfinding(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)

    def perform_export(self, instances):
        return export_templates(instances)
    
    def perform_import(self, archive, data, **kwargs):
        return import_templates(archive, **kwargs)


class FindingTemplateTranslationViewSet(TemplateSubresourceMixin, HistoryTimelineViewSetMixin, viewsets.ModelViewSet):
    serializer_class = FindingTemplateTranslationSerializer

    def get_queryset(self):
        return self.get_template().translations.all().default_order()
    
    def perform_destroy(self, instance):
        if instance.is_main:
            raise ValidationError('Cannot delete main template language')
        return super().perform_destroy(instance)
    
    def get_history_timeline_queryset_parts(self):
        return [
            FindingTemplateTranslation.history.filter(template_id=self.get_template().id).filter(id=self.kwargs['pk'])
        ] + ([
            self.get_template().history.all(),
            FindingTemplateTranslation.history.filter(template_id=self.get_template().id).filter(history_type__in=['+', '-']),
        ] if self.request.GET.get('include_template_timeline') else [])


class FindingTemplateHistoryViewSet(TemplateSubresourceMixin, HistoryViewSetBase):
    serializer_class = FindingTemplateSerializer
    permission_classes = TemplateSubresourceMixin.permission_classes + [license.ProfessionalLicenseRequired]

    def get_base_object(self):
        return self.get_template()
        
    def retrieve(self, request, *args, **kwargs):
        return self.retrieve_historic(prefetch=[
            Prefetch('translations', FindingTemplateTranslation.history \
                .as_of(self.get_history_date())
                .annotate(is_main_order=Q(id=F('template__main_translation_id')))
                .order_by('-is_main_order', 'created'))
        ])
    
    @extend_schema(responses={(200, 'application/octet-stream'): OpenApiTypes.BINARY})
    @action(detail=True, url_path='images/name/(?P<filename>[^/]+)')
    @method_decorator(cache_control(max_age=60 * 60 * 24, private=True))
    def image_by_name(self, request, *arg, **kwargs):
        return self.retrieve_historic_file(UploadedTemplateImage, filename=self.kwargs['filename'])


class UserPublicKeyViewSet(UserSubresourceViewSetMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet):
    serializer_class = UserPublicKeySerializer
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES + [UserPublicKeyPermissions, license.ProfessionalLicenseRequired]

    def get_queryset(self):
        return self.get_user().public_keys.all()
    
    def get_serializer_class(self):
        if self.action == 'register_begin':
            return UserPublicKeyRegisterBeginSerializer
        return super().get_serializer_class()
    
    @action(detail=False, url_path='register/begin', methods=['post'])
    def register_begin(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        instance = serializer.save()

        # Verify that users can decrypt with the given public key before registering
        test_data = 'key-verification-' + str(uuid4()) + '\n'
        verification_encrypted = instance.encrypt(test_data.encode())
        self.request.session['public_key_register'] = {
            'instance': model_to_dict(instance),
            'verification': test_data,
        }
        return Response(data={
            'status': 'verify-key',
            'public_key_info': instance.public_key_info,
            'verification': verification_encrypted,
        })
    
    @action(detail=False, url_path='register/complete', methods=['post'])
    def register_complete(self, request, *args, **kwargs):
        public_key_register_state = request.session.get('public_key_register')
        if not public_key_register_state:
            raise APIBadRequestError('No public key registration in progress')
        if public_key_register_state['verification'].strip() != request.data.get('verification', '').strip():
            raise ValidationError('Invalid verification code')

        instance = UserPublicKey(**public_key_register_state['instance'])
        instance.user = self.get_user()
        instance.save()
        serializer = self.get_serializer(instance=instance)
        return Response(data=serializer.data, status=status.HTTP_201_CREATED)

    def perform_destroy(self, instance):
        try:
            instance.delete()
        except ProtectedError:
            raise ValidationError(
                detail='Cannot delete this public key because some archives are encrypted with it. ' +
                       'You can disable it to not be used for archiving in the future.')
